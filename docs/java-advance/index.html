<!DOCTYPE html>
<html lang="en-US">
<link rel="stylesheet" href="/css/gallery.css">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="I&rsquo;m a software engineer borned in 2000. Love my work and life.">
<meta name="author" content="Caiyi Zhang">

<title>Java Advance · CaiyiZhang&rsquo;s Blog</title>

<link rel="canonical" href="/docs/java-advance/">




  <link rel="stylesheet" href="/assets/css/docs.min.dcabf270c88fb205b746f7955d094e4fc1571e71c6ecb2549658cc810d16e4cf.css" integrity="">




  <link rel="preconnect" href="https://-dsn.algolia.net" crossorigin />
  
  <link rel="stylesheet" href="/css/component/docsearch.min.cb5a1c417ef755c9bf17808583cb389f7f745310f105256d2c11714b3cfad6df.css" integrity=""/>

<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/img/icon/favicon.ico">
<link rel="icon" href="/img/icon/icon-16.png" sizes="16x16" type="image/png">
<link rel="icon" href="/img/icon/icon-32.png" sizes="32x32" type="image/png">
<link rel="apple-touch-icon" href="/img/icon/icon-180.png" sizes="180x180">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#121212" media="(prefers-color-scheme: dark)">

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-XXXXXXXXXX');
  </script>


  

  </head>
  <body>
    <header id="site-header">
  
  <div id="site-header-brand">
    <a href="/">CaiyiZhang&#39;s Blog</a>
  </div>

  
  <div id="site-header-controls">
    
    <div class="dropdown">
      <button class="dropdown-btn" aria-haspopup="menu" aria-label="theme selector">
        <i class="icon icon-brightness"></i>
        <i class="icon icon-select"></i>
      </button>
      <ul role="menu" class="dropdown-menu">
        <li role="menuitem"><button class="color-scheme" data-value="light"><i class="icon icon-light-mode"></i> Light</button></li>
        <li role="menuitem"><button class="color-scheme" data-value="dark"><i class="icon icon-dark-mode"></i> Dark &nbsp;</button></li>
        <li role="menuitem"><button class="color-scheme" data-value="night"><i class="icon icon-night-mode"></i> Night</button></li>
      </ul>
    </div>

  </div>

  
  <div id="site-header-menu">
    <nav>
      <ul>
        
        
        
          
          <li><a href="/" ><i class='icon icon-home'></i>Home</a></li>
        
          
          <li><a href="/docs"  class="active"><i class='icon icon-book'></i>Blogs</a></li>
        
          
          <li><a href="/life" ><i class='icon icon-dark-mode'></i>Life</a></li>
        
      </ul>
    </nav>
  </div>

  
  <div id="site-header-search"></div>
</header>
    
<div id="site-main-content-wrapper">
  
  
    


<aside id="sidebar">
  <span class="btn-close"><i class="icon icon-close"></i></span>

  <div class="sticky"><strong class="sidebar-section">Overview</strong>
          
          <a class="sidebar-link " href="/docs/aboutme/">
            
              AboutMe
            
          </a>

        <strong class="sidebar-section">Languages</strong>
          
          <a class="sidebar-link " href="/docs/java-basic/">
            
              Java Basic
            
          </a>

        
          
          <a class="sidebar-link current" href="/docs/java-advance/">
            
              Java Advance
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/java-data-structure/">
            
              Java Data Structure
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/java-input-output/">
            
              Java Input-Output
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/python-basic/">
            
              Python Basic
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/java-native-interface/">
            
              Java Native Interface
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/c-plus-plus/">
            
              C plus plus
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/javascript/">
            
              JavaScript
            
          </a>

        <strong class="sidebar-section">Computer Science</strong>
          
          <a class="sidebar-link " href="/docs/github-usage/">
            
              Github Usage
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/computer-network/">
            
              Computer Network
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/operating-system/">
            
              Operating System
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/database-principal/">
            
              Database Principal
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/software-testing/">
            
              Software Testing
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/functional-programing/">
            
              Functional Programing
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/object-oriented-design/">
            
              Object-Oriented Design
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/compiler-principles/">
            
              Compiler Principles
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/linux-operation/">
            
              Linux Operation
            
          </a>

        <strong class="sidebar-section">Video Develop</strong>
          
          <a class="sidebar-link " href="/docs/ffmpeg/">
            
              FFMpeg
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/android-camera-2/">
            
              Android Camera 2
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/video-compression/">
            
              Video Compression
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/video-knowledge/">
            
              Video Knowledge
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/andriod-development/">
            
              Andriod Development
            
          </a>

        <strong class="sidebar-section">Backend Develop</strong>
          
          <a class="sidebar-link " href="/docs/express/">
            
              Express
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/fast-api/">
            
              Fast API
            
          </a>

        <strong class="sidebar-section">Frontend Develop</strong>
          
          <a class="sidebar-link " href="/docs/html5/">
            
              HTML5
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/css3/">
            
              CSS3
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/vue-js/">
            
              Vue js
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/react-js/">
            
              React js
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/react-native/">
            
              React Native
            
          </a>

        
          
          <a class="sidebar-link " href="/docs/mern-e-commerce/">
            
              MERN E-Commerce
            
          </a>

        
  </div>
</aside>

  
  <main>
    <article id="article">
      <nav id="article-nav">
  <button id="article-nav-menu-btn"><i class="icon icon-menu"></i> On this section</button>
  <button id="article-nav-toc-btn"><i class="icon icon-toc"></i> On this page</button>
</nav>
      <header id="article-header">
  <h1>Java Advance</h1>
</header>
      <div id="article-content">
        
        
        <h1 id="面向对象设计实践基于java"><strong>面向对象设计实践（基于java）</strong></h1>
<p>caiyi 2021/10/1</p>
<p>source：<a href="https://www.icourse163.org/spoc/course/ECNU-1464731161" target="_blank">https://www.icourse163.org/spoc/course/ECNU-1464731161</a></p>
<p>期末划考试范围：junit单元测试，第三章文本处理，第四章文件处理，第五章多线程并行（5.4 5.7 5.8很少考 5.9定时任务要考），第六章网络编程（6.6 6.7 6.8不考），第七章数据库编程（7.3不考），第八章（8.1-8.4考的少 只考8.5 8.6）</p>
<h1 id="第一章-maven"><strong>第一章 Maven</strong></h1>
<h3 id="maven概念"><strong>Maven概念</strong></h3>
<p>自动下载和管理jar包，配置build path，存在本地进行管理，编译、测试、运行、和打包发布java项目的构建工具</p>
<h3 id="maven编译工作流程"><strong>Maven编译工作流程</strong></h3>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001132252.png" alt=""></p>
<h3 id="maven目录结构"><strong>Maven目录结构</strong></h3>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001132455.png" alt=""></p>
<h3 id="maven项目构建流程"><strong>Maven项目构建流程</strong></h3>
<p>首先创建maven项目</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001125649.png" alt=""></p>
<p>选择 maven project</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001125744.png" alt=""></p>
<p>勾选 create a simple project</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001125831.png" alt=""></p>
<p>输入 group id （组织名）、artifact id（作品名/项目名）</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001125935.png" alt=""></p>
<p>然后在mvn中央仓库搜索工具包的名字</p>
<p><a href="https://mvnrepository.com/" target="_blank">https://mvnrepository.com/</a></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001130325.png" alt=""></p>
<p>选择合适的版本，复制依赖文本</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001130451.png" alt=""></p>
<p>将依赖文本添加到项目pom.xml中</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001130613.png" alt=""></p>
<p>Maven编译和运行</p>
<p>右键项目 → Run As → Maven Build</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001130643.png" alt=""></p>
<p>在Goals输入 clean package → Apply → Run</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001130809.png" alt=""></p>
<p>编译成功</p>
<p>编译过程中他会自动把jar包下载下来</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001130909.png" alt=""></p>
<p>运行程序</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001131203.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001131340.png" alt=""></p>
<p><strong>总结，构建工具的功能</strong></p>
<ul>
<li>自动帮程序员甄别和下载第三方库（jar）</li>
<li>完成整个项目编译（调用javac.exe）</li>
<li>完成整个项目单元测试流程（调用JUnit工具）</li>
<li>完成项目打包（jar/war等格式，调用jar.exe）</li>
</ul>
<p><strong>一些常用的依赖文本</strong></p>
<p>opencc4j 简体转繁体</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.houbb&lt;/groupId&gt;
    &lt;artifactId&gt;opencc4j&lt;/artifactId&gt;
    &lt;version&gt;1.7.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>Junit 测试</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.13&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>commons math 数学</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-math3&lt;/artifactId&gt;
    &lt;version&gt;3.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>pinyin4j 汉字转拼音</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.belerweb&lt;/groupId&gt;
    &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;
    &lt;version&gt;2.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="maven报错解决办法"><strong>Maven报错解决办法</strong></h3>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001141812.png" alt=""></p>
<p>在pom.xml中添加以下配置语句</p>
<pre tabindex="0"><code>&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre><h1 id="第二章-单元测试和junit"><strong>第二章 单元测试和Junit</strong></h1>
<p><strong>软件测试</strong></p>
<p>在规定的条件下对程序进行操作， 以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程</p>
<p><strong>软件测试分类</strong></p>
<p>单元 vs 集成测试</p>
<p>白盒 vs 黑盒测试</p>
<p>自动 vs 手动测试</p>
<p>回归测试、压力测试</p>
<p><strong>JUnit</strong>：一个java语言的单元测试框架，大部分java IDE都集成了JUnit作为单元测试工具</p>
<p><strong>JUnit 用法</strong></p>
<p>用上一章的方法新建一个maven项目</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001135254.png" alt=""></p>
<p>⭐️记得在 pom.xml 里导入 JUnit 的依赖文本，否则会报错</p>
<pre tabindex="0"><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>观察项目目录，我们在src/main/java 里面放业务代码，src/test/java 里面放测试代码</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001140943.png" alt=""></p>
<p>在 src/main/java 新建 LeapYear.java，给定一个年份，判断是不是闰年</p>
<pre tabindex="0"><code>public class LeapYear {

    public boolean isLeapYear(int year) {
        if(year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0){
            return true;
        }
        else{
            return false;
        }
    }
}
</code></pre><p>在 src/test/java 新建 LeapYearTest.java</p>
<p>每一个测试方法的头部加@Test注解，这样JUnit会自动执行这些测试方法</p>
<p>import是导入一个类或者几个类，import static是导入某一个类的所有静态方法，以便我们在程序调用的时候不需要再写 Assert.assertEquals()</p>
<pre tabindex="0"><code>import static org.junit.Assert.*;
import org.junit.Test;

public class LeapYearTest {

    @Test
    public void test() {
        assertEquals(true,new LeapYear().isLeapYear(2020));
        assertEquals(false,new LeapYear().isLeapYear(2019));
    }
}
</code></pre><p>junit单元测试，右键LeapYearTest.java → Run As → JUnit Test</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001140537.png" alt=""></p>
<p>结果正确！</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001140702.png" alt=""></p>
<p>修改一下代码，运行结果错误！和我们期待的值不一样</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001140749.png" alt=""></p>
<p>我们也可以通过<strong>Maven Test</strong>来运行JUnit程序</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001141243.png" alt=""></p>
<p>运行错误</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001142552.png" alt=""></p>
<p>修改第八行的 false 为 true，运行正确</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001142712.png" alt=""></p>
<p><strong>二者区别</strong></p>
<p>JUnit一次只能执行一个test类，Maven可以批量执行</p>
<h1 id="第三章-高级文本处理"><strong>第三章 高级文本处理</strong></h1>
<h2 id="31-java字符编码"><strong>3.1 Java字符编码</strong></h2>
<p><strong>ASCII码</strong></p>
<p>用一个字节(1 Byte = 8 bits)来存储 a-z A-Z 0-9和一些常用的符号，回车13，零48，A65，a97</p>
<p><strong>Unicode编码</strong></p>
<p>编码方案有UTF-8，兼容ASCII，变长1-4个字节存储字符，经济方便传输</p>
<p><strong>Java的字符编码</strong></p>
<p>源文件编码：采用UTF-8编码</p>
<p>程序内部采用UTF-16编码存储所有字符(不是程序员控制)</p>
<p>和外界(文本文件)的输入输出尽量采用UTF-8编码</p>
<p><strong>通过几个程序了解一下Java字符编码</strong></p>
<p>获取默认字符集，本机默认是GBK</p>
<p>输出所有支持的字符集</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001145542.png" alt=""></p>
<p>用UTF-8格式写入文件</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001150528.png" alt=""></p>
<p>写入成功</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001150606.png" alt=""></p>
<p>接着用UTF-8编码读取文件</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001150825.png" alt=""></p>
<p>读取成功！</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001150846.png" alt=""></p>
<p>再试试用 GBK 编码读取文件呢，可以发现它乱码了</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001151022.png" alt=""></p>
<h2 id="32-java国际化编程"><strong>3.2 Java国际化编程</strong></h2>
<p>多语言版本的软件，一套语言多个语言包，根据语言设定，可以切换显示文本</p>
<p><strong>主要用到两个类</strong></p>
<pre tabindex="0"><code>java.util.ResourceBundle 用于加载一个语言_国家语言包
java.util.Locale 定义一个语言_国家
</code></pre><p><strong>Locale类</strong></p>
<p>属性：语言(zh, en)，国家地区(CN, US)</p>
<p>方法：getAvailableLocales(), getDefault()返回默认的</p>
<p><strong>ResourceBundle类</strong></p>
<p>→ 根据 Locale 的值加载对应的properties文件</p>
<p>→ 存储语言集合中所有的K-V对</p>
<p>→ getString(String key) 返回所对应的value</p>
<h3 id="properties语言文件"><strong>properties语言文件</strong></h3>
<p>我们所有的文本值都放在 properties文件里面，存放的都是KV对，存储文件必须是ASCII编码或Unicode编码</p>
<p>命名规则：包名 _ 语言 _ 国家地区.properties、</p>
<p>可以采用native2ascii.exe进行转码</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001152830.png" alt=""></p>
<h3 id="国际化转化演示"><strong>国际化转化演示</strong></h3>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001162746.png" alt=""></p>
<p>所有的文本值都放在 properties文件里面</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001173236.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001173252.png" alt=""></p>
<p><strong>其他国际化</strong></p>
<p>日期时间国际化 DateTimeFormatter和Locale的结合</p>
<p>数字金额国际化 NumberFormat和Locale的结合</p>
<h3 id="解决引入javautil-爆红的方法"><strong>解决引入java.util 爆红的方法</strong></h3>
<p>右键项目 → Build Path → Configure Build Path</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001155245.png" alt=""></p>
<p>Java Build Path → Libraries选项卡 → 右侧Add Library按钮 → JRE System Library</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001161003.png" alt=""></p>
<h2 id="33-高级字符串处理"><strong>3.3 高级字符串处理</strong></h2>
<h3 id="331-正则表达式"><strong>3.3.1 正则表达式</strong></h3>
<p>用事先定义好的一些特定字符、及这些特定字符的组合，组成一 个“规则字符串”，用于测试字符串内的模式、识别和替换文本、提取文本</p>
<p><strong>匹配模板</strong>：定界符、原子、特殊功能字符、模式修正符</p>
<p><strong>Java.util.regex包</strong></p>
<ul>
<li>
<p>Pattern 正则表达式的编译表示</p>
<p>compile 编译一个正则表达式为Pattern对象</p>
<p>matcher 用Pattern对象匹配一个字符串，返回匹配结果</p>
</li>
<li>
<p>Matcher</p>
<p>Index Methods(位置方法)     // start(), start(int group), end(), end(int group)</p>
<p>Study Methods(查找方法)    // lookingAt(), find(), find(int start), matches()</p>
<p>Replacement Methods(替换方法)   //replaceAll(String replacement)</p>
</li>
</ul>
<p><strong>例子</strong></p>
<p>example1：一个pattern就代表一个正则表达式</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001171431.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001171522.png" alt=""></p>
<p>example2：lookingAt()和matches()的区别</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001171648.png" alt=""></p>
<p>example3：替换掉满足匹配模式的字符串为另一个替换字符文额 e</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001172319.png" alt=""></p>
<p>example4：把所有dog替换为cat，dogs替换为cats</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001172520.png" alt=""></p>
<p>example5：用replaceAll()的方法修改example3</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001172746.png" alt=""></p>
<p>example6：邮箱的正则表达式判断</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211001172958.png" alt=""></p>
<pre tabindex="0"><code>public static  void regularExpression() {
    String REGEX_EMAIL = &#34;^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+(([.\\-])[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$&#34;;//email
    Pattern pattern = Pattern.compile(REGEX_EMAIL);

    String[] emails = new String[]{&#34;123^@qq.com&#34;, &#34;name_321@163.com&#34;, &#34;+whatever*72@gmail.com&#34;};
    for(String email : emails) {
        Matcher matcher = pattern.matcher(email);
        if (matcher.matches()) {
            System.out.println(email + &#34; is valid email.&#34;);
        } else {
            System.out.println(email + &#34; is not valid email.&#34;);
        }
    }
}
</code></pre><h3 id="332-其他字符串处理"><strong>3.3.2 其他字符串处理</strong></h3>
<h3 id="集合和字符串互转"><strong>集合和字符串互转</strong></h3>
<p>引入依赖文件</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
    &lt;version&gt;3.12.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>import依赖包</p>
<pre tabindex="0"><code>import org.apache.commons.lang3.StringUtils;

public class String2List {

    public static void main(String[] args) {
        List&lt;String&gt; names = new LinkedList&lt;String&gt;();
        names.add(&#34;Xiaohong&#34;);
        names.add(&#34;Xiaoming&#34;);
        names.add(&#34;Daming&#34;);
        names.add(&#34;Xiaohei&#34;);

        //从ArrayList变到字符串
        String str1 = String.join(&#34;,&#34;, names);  //String.join， JDK 8 引入
        System.out.println(str1);

        String str2 = StringUtils.join(names, &#34;,&#34;);  //Apache Commons Lang
        System.out.println(str2);

        //从字符串变回ArrayList
        List&lt;String&gt; names2 = Arrays.asList(str2.split(&#34;,&#34;));
        for(String name:names2)
        {
            System.out.println(name);
        }

        //StringUtils 可以支持更多数据类型
        List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();
        ids.add(1);
        ids.add(3);
        ids.add(5);
        String str3 = StringUtils.join(ids, &#34;,&#34;);
        System.out.println(str3);
    }

}
</code></pre><pre tabindex="0"><code>OUTPUT

Xiaohong,Xiaoming,Daming,Xiaohei
Xiaohong,Xiaoming,Daming,Xiaohei
Xiaohong
Xiaoming
Daming
Xiaohei
1,3,5
</code></pre><h3 id="字符串转义"><strong>字符串转义</strong></h3>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-text&lt;/artifactId&gt;
    &lt;version&gt;1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><pre tabindex="0"><code>import org.apache.commons.text.StringEscapeUtils;
public class EscapeString {

    public static void main(String[] args) {
        String str = &#34;He didn&#39;t say, \&#34;Stop!\&#34;&#34;;

        //转义
        String escapedStr = StringEscapeUtils.escapeJava(str);
        System.out.println(&#34;escape&#34; + &#34;:&#34; + escapedStr);

        //从转义字符串转回来
        String str2 = StringEscapeUtils.unescapeJava(escapedStr);
        System.out.println(&#34;unescape&#34; + &#34;:&#34; + str2);
    }
}
</code></pre><pre tabindex="0"><code>OUTPUT
escape:He didn&#39;t say, \&#34;Stop!\&#34;
unescape:He didn&#39;t say, &#34;Stop!&#34;
</code></pre><h3 id="变量名字格式化驼峰命名"><strong>变量名字格式化(驼峰命名)</strong></h3>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;27.0.1-jre&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><pre tabindex="0"><code>import com.google.common.base.CaseFormat;
import com.google.common.base.Splitter;
import com.google.common.collect.Lists;

public class GuavaUtil {
    public static void main(String[] args) throws Exception {
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(123);
        list.add(456);
        System.out.println(list);

        //直接初始化List数组
        List&lt;Integer&gt; integers = Lists.newArrayList(123, 456);
        System.out.println(integers);

        //拆分字符串，忽略空字符串
        Iterable&lt;String&gt; split = Splitter.on(&#39;,&#39;)
                .trimResults()
                .omitEmptyStrings()
                .split(&#34;123,321,,   abc&#34;);

        for (String s : split) {
            System.out.println(s);
        }

        //对比常规方法拆分字符串，忽略空字符串
        String a = &#34;123,321,,   abc&#34;;
        String[] as = a.split(&#34;,&#34;);

        for(int i=0;i&lt;as.length;i++)
        {
            if(null == as[i] || as[i].length()&lt;=0)
            {
                continue;
            }
            else
            {
                System.out.println(as[i].trim());
            }
        }

        //驼峰命名
        String s1 = &#34;CONSTANT_NAME&#34;;
        String s2 = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, s1);
        System.out.println(s2); //constantName;
    }
}
</code></pre><h3 id="从字符串到输入流"><strong>从字符串到输入流</strong></h3>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><pre tabindex="0"><code>import org.apache.commons.io.Charsets;
import org.apache.commons.io.IOUtils;

public class String2InputStream {
    public static void main(String[] args) {

        //构造字符串列表
        List&lt;String&gt; names = new LinkedList&lt;String&gt;();
        names.add(&#34;Xiaohong&#34;);
        names.add(&#34;Xiaoming&#34;);
        names.add(&#34;Daming&#34;);
        names.add(&#34;Xiaohei&#34;);

        //合并为一个字符串，以逗号相连
        String nameStr = String.join(&#34;,&#34;,names);

        //将字符串作为默认的输入流
        InputStream in = IOUtils.toInputStream(nameStr, Charsets.toCharset(&#34;UTF-8&#34;));
        //重置系统的输入流
        System.setIn(in);

        //模拟键盘输入  这也是OJ平台测试用例输入的原理
        //此处也可以换成一个文件输入流
        Scanner sc=new Scanner(System.in);
        sc.useDelimiter(&#34;,&#34;);
        while(sc.hasNext())
        {
            System.out.println(sc.next());
        }

    }
}
</code></pre><h1 id="第四章-高级文件处理"><strong>第四章 高级文件处理</strong></h1>
<h2 id="41-xml-dom解析"><strong>4.1 XML DOM解析</strong></h2>
<p>可扩展标记语言：意义加数据</p>
<p>DOM/SAX/Stax是JDK自带的解析功能</p>
<p><strong>xml解析方法</strong></p>
<p>树结构：DOM 文档对象模型</p>
<p>流结构：SAX 流机制解析器（推）、Stax 流机制解析器（拉）</p>
<p><strong>DOM方法</strong></p>
<p>其处理方式是将 XML 整个作为类似树结构的方式读入内存中</p>
<p>解析大数据量的 XML 文件，会遇到内存泄露及程序崩溃的风险。</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211002133554.png" alt=""></p>
<ul>
<li>DocumentBuilder 解析类，parse方法</li>
<li>Node 节点主接口，getChildNodes返回一个NodeList</li>
<li>NodeList 节点列表，每个元素是一个Node</li>
<li>Document 文档根节点</li>
<li>Element 标签节点元素 (每一个标签都是标签节点)</li>
<li>Text节点 (包含在XML元素内的，都算Text节点)</li>
<li>Attr节点(每个属性节点)</li>
</ul>
<p><strong>读取dom方法一，自上而下解析：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">用到的函数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">getNodeName</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">getTextContent</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">getChildNodes</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Node</span><span class="p">.</span><span class="na">ELEMENT_NODE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">usersList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">recursiveTraverse</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//采用Dom解析xml文件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DocumentBuilderFactory</span><span class="w"> </span><span class="n">dbf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DocumentBuilderFactory</span><span class="p">.</span><span class="na">newInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DocumentBuilder</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dbf</span><span class="p">.</span><span class="na">newDocumentBuilder</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Document</span><span class="w"> </span><span class="n">document</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">db</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;users.xml&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//获取所有的一级子节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">NodeList</span><span class="w"> </span><span class="n">usersList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">getChildNodes</span><span class="p">();</span><span class="w"> </span><span class="c1">//长度为1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//一级节点开始遍历</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">usersList</span><span class="p">.</span><span class="na">getLength</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usersList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">         </span><span class="c1">//1  users</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">NodeList</span><span class="w"> </span><span class="n">userList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="na">getChildNodes</span><span class="p">();</span><span class="w"> </span><span class="c1">//获取二级子节点user的列表，长度为9</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//二级节点开始遍历</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">userList</span><span class="p">.</span><span class="na">getLength</span><span class="p">();</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="c1">//9</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">userList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="na">getNodeType</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="na">ELEMENT_NODE</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">NodeList</span><span class="w"> </span><span class="n">metaList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="na">getChildNodes</span><span class="p">();</span><span class="w">  </span><span class="c1">//长度为7</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//三级节点开始遍历</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">metaList</span><span class="p">.</span><span class="na">getLength</span><span class="p">();</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="c1">//7</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="c1">//到最后一级文本</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">Node</span><span class="w"> </span><span class="n">meta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">metaList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="na">getNodeType</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="na">ELEMENT_NODE</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">metaList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="na">getNodeName</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                               </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;:&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">metaList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="na">getTextContent</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>读取dom方法二，搜索：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">traverseBySearch</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//采用Dom解析xml文件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DocumentBuilderFactory</span><span class="w"> </span><span class="n">dbf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DocumentBuilderFactory</span><span class="p">.</span><span class="na">newInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DocumentBuilder</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dbf</span><span class="p">.</span><span class="na">newDocumentBuilder</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Document</span><span class="w"> </span><span class="n">document</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">db</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;users.xml&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Element</span><span class="w"> </span><span class="n">rootElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">getDocumentElement</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">NodeList</span><span class="w"> </span><span class="n">nodeList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rootElement</span><span class="p">.</span><span class="na">getElementsByTagName</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">nodeList</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nodeList</span><span class="p">.</span><span class="na">getLength</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Element</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Element</span><span class="p">)</span><span class="n">nodeList</span><span class="p">.</span><span class="na">item</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="na">getNodeName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; = &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="na">getTextContent</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>基于dom技术写xml文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DomWriter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">DocumentBuilderFactory</span><span class="w"> </span><span class="n">dbFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DocumentBuilderFactory</span><span class="p">.</span><span class="na">newInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">DocumentBuilder</span><span class="w"> </span><span class="n">dbBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dbFactory</span><span class="p">.</span><span class="na">newDocumentBuilder</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//新创建一个Document节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Document</span><span class="w"> </span><span class="n">document</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dbBuilder</span><span class="p">.</span><span class="na">newDocument</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">document</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Element</span><span class="w"> </span><span class="n">docx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">createElement</span><span class="p">(</span><span class="s">&#34;document&#34;</span><span class="p">);</span><span class="w">  </span><span class="c1">//都是采用Document创建元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Element</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">createElement</span><span class="p">(</span><span class="s">&#34;element&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">element</span><span class="p">.</span><span class="na">setAttribute</span><span class="p">(</span><span class="s">&#34;type&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;paragraph&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">element</span><span class="p">.</span><span class="na">setAttribute</span><span class="p">(</span><span class="s">&#34;alignment&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;left&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">//element增加2个属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Element</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">createElement</span><span class="p">(</span><span class="s">&#34;object&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">object</span><span class="p">.</span><span class="na">setAttribute</span><span class="p">(</span><span class="s">&#34;type&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;text&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Element</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">createElement</span><span class="p">(</span><span class="s">&#34;text&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">text</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">document</span><span class="p">.</span><span class="na">createTextNode</span><span class="p">(</span><span class="s">&#34;abcdefg&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">//给text节点赋值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Element</span><span class="w"> </span><span class="n">bold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="na">createElement</span><span class="p">(</span><span class="s">&#34;bold&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">bold</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">document</span><span class="p">.</span><span class="na">createTextNode</span><span class="p">(</span><span class="s">&#34;true&#34;</span><span class="p">));</span><span class="w">    </span><span class="c1">//给bold节点赋值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">object</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">text</span><span class="p">);</span><span class="w">      </span><span class="c1">//把text节点挂在object下</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">object</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">bold</span><span class="p">);</span><span class="w">      </span><span class="c1">//把bold节点挂在object下</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">element</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">object</span><span class="p">);</span><span class="w">   </span><span class="c1">//把object节点挂在element下</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">docx</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">element</span><span class="p">);</span><span class="w">     </span><span class="c1">//把element节点挂在docx下</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">document</span><span class="p">.</span><span class="na">appendChild</span><span class="p">(</span><span class="n">docx</span><span class="p">);</span><span class="w">    </span><span class="c1">//把docx挂在document下</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">TransformerFactory</span><span class="w"> </span><span class="n">transformerFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TransformerFactory</span><span class="p">.</span><span class="na">newInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Transformer</span><span class="w"> </span><span class="n">transformer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformerFactory</span><span class="p">.</span><span class="na">newTransformer</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">DOMSource</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DOMSource</span><span class="p">(</span><span class="n">document</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//定义目标文件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">File</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">File</span><span class="p">(</span><span class="s">&#34;dom_result.xml&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">StreamResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StreamResult</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//将xml内容写入到文件中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">transformer</span><span class="p">.</span><span class="na">transform</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;write xml file successfully&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>运行结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">document</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&lt;</span><span class="n">element</span><span class="w"> </span><span class="n">alignment</span><span class="o">=</span><span class="s">&#34;left&#34;</span><span class="w"> </span><span class="n">type</span><span class="o">=</span><span class="s">&#34;paragraph&#34;</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&lt;</span><span class="n">object</span><span class="w"> </span><span class="n">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">&lt;</span><span class="n">text</span><span class="o">&gt;</span><span class="n">abcdefg</span><span class="o">&lt;/</span><span class="n">text</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">&lt;</span><span class="n">bold</span><span class="o">&gt;</span><span class="kc">true</span><span class="o">&lt;/</span><span class="n">bold</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&lt;/</span><span class="n">object</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&lt;/</span><span class="n">element</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">&lt;/</span><span class="n">document</span><span class="o">&gt;</span><span class="w">
</span></span></span></code></pre></div><h2 id="42-sax-dom解析"><strong>4.2 SAX DOM解析</strong></h2>
<p>Simple API for XML</p>
<p>采用事件/流模型来解析 XML 文档，更快速、更轻量。</p>
<p>有选择的解析和访问，不像 DOM 加载整个文档，内存要求较低。</p>
<p>SAX 对 XML 文档的解析为一次性读取，不创建/不存储文档对象，很难同时访问文档中的多处数据。</p>
<p>推模型：当它每发现一个节点就引发一个事件，而我们需要编写这些事件的处理程序，defaulthandler</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SAXReader</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SAXException</span><span class="p">,</span><span class="w"> </span><span class="n">IOException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">XMLReader</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMLReaderFactory</span><span class="p">.</span><span class="na">createXMLReader</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">BookHandler</span><span class="w"> </span><span class="n">bookHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BookHandler</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">parser</span><span class="p">.</span><span class="na">setContentHandler</span><span class="p">(</span><span class="n">bookHandler</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">parser</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;books.xml&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">bookHandler</span><span class="p">.</span><span class="na">getNameList</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//定义响应程序，必须继承DefaultHandler</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">BookHandler</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">DefaultHandler</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nameList</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">getNameList</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">nameList</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// xml文档加载时</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">startDocument</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SAXException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Start parsing document...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">nameList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 文档解析结束</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">endDocument</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SAXException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;End&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 访问某一个元素，qname指每个尖括号里面的名字</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">startElement</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">uri</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">localName</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">qName</span><span class="p">,</span><span class="w"> </span><span class="n">Attributes</span><span class="w"> </span><span class="n">atts</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SAXException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qName</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&#34;title&#34;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">//要解析其他元素只需要改这里，比如把“title”改为“year”</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 结束访问元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">endElement</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">namespaceURI</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">localName</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">qName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SAXException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// End of processing current element</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">title</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 访问元素正文</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">characters</span><span class="p">(</span><span class="kt">char</span><span class="o">[]</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">title</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">String</span><span class="w"> </span><span class="n">bookTitle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Book title: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bookTitle</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">nameList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">bookTitle</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="43-stax-dom解析"><strong>4.3 Stax DOM解析</strong></h2>
<p>Streaming API for XML</p>
<p>流模型中的拉模型</p>
<p>在遍历文档时，会把感兴趣的部分从读取器中拉出，不需要引发事件，允许我们选择性地处理节点</p>
<p><strong>两套处理API：</strong></p>
<p>基于指针的API， XMLStreamReader</p>
<p>基于迭代器的API，XMLEventReader</p>
<p><strong>方法一，流模式</strong></p>
<pre tabindex="0"><code>public static void readByStream() {
    String xmlFile = &#34;books.xml&#34;;
    XMLInputFactory factory = XMLInputFactory.newFactory();
    XMLStreamReader streamReader = null;
    try {
        streamReader = factory.createXMLStreamReader(new FileReader(xmlFile));
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (XMLStreamException e) {
        e.printStackTrace();
    }

    // 基于指针遍历
    try {
        while (streamReader.hasNext()) {
            int event = streamReader.next();
            // 如果是元素的开始
            if (event == XMLStreamConstants.START_ELEMENT) {
                // 列出所有书籍名称
                if (&#34;title&#34;.equalsIgnoreCase(streamReader.getLocalName())) {
                    System.out.println(&#34;title:&#34; + streamReader.getElementText());
                }
                if (&#34;year&#34;.equalsIgnoreCase(streamReader.getLocalName())) {
                    System.out.println(&#34;year:&#34; + streamReader.getElementText());
                }
            }
        }
        streamReader.close();
    } catch (XMLStreamException e) {
        e.printStackTrace();
    }
}
</code></pre><p><strong>方法二，事件模式</strong></p>
<p>有点没看懂</p>
<pre tabindex="0"><code>public static void readByEvent() {
    String xmlFile = &#34;books.xml&#34;;
    XMLInputFactory factory = XMLInputFactory.newInstance();
    boolean titleFlag = false;
    try {
        // 创建基于迭代器的事件读取器对象
        XMLEventReader eventReader = factory.createXMLEventReader(new FileReader(xmlFile));
        // 遍历Event迭代器
        while (eventReader.hasNext()) {
            XMLEvent event = eventReader.nextEvent();
            // 如果事件对象是元素的开始
            if (event.isStartElement()) {
                // 转换成开始元素事件对象
                StartElement start = event.asStartElement();
                // 打印元素标签的本地名称

                String name = start.getName().getLocalPart();
                //System.out.print(start.getName().getLocalPart());
                if(name.equals(&#34;title&#34;))
                {
                    titleFlag = true;
                    System.out.print(&#34;title:&#34;);
                }

                // 取得所有属性
                Iterator attrs = start.getAttributes();
                while (attrs.hasNext()) {
                    // 打印所有属性信息
                    Attribute attr = (Attribute) attrs.next();
                    //System.out.print(&#34;:&#34; + attr.getName().getLocalPart() + &#34;=&#34; + attr.getValue());
                }
                //System.out.println();
            }

            //如果是正文
            if(event.isCharacters())
            {
                String s = event.asCharacters().getData();
                if(null != s &amp;&amp; s.trim().length()&gt;0 &amp;&amp; titleFlag)
                {
                    System.out.println(s.trim());
                }
            }
            //如果事件对象是元素的结束
            if(event.isEndElement())
            {
                EndElement end = event.asEndElement();
                String name = end.getName().getLocalPart();
                if(name.equals(&#34;title&#34;))
                {
                    titleFlag = false;
                }
            }
        }
        eventReader.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (XMLStreamException e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="44-json解析"><strong>4.4 JSON解析</strong></h2>
<p>是一种轻量级的数据交换格式，类似XML，更小、更快、更易解析</p>
<p>最早用于Javascript中，容易解析，最后推广到全语言</p>
<p>尽管使用Javascript语法，但是独立于编程语言</p>
<p><strong>三个JSON处理的包：</strong></p>
<ul>
<li>org.json：JSON官方推荐的解析类</li>
<li>GSON：Google出品</li>
<li>Jackson：号称最快的JSON处理器</li>
</ul>
<p><strong>Java Bean对象：</strong></p>
<ul>
<li>具有一个无参的构造函数</li>
<li>可以包括多个属性，所有属性都是private</li>
<li>每个属性都有相应的Getter/Setter方法</li>
</ul>
<h3 id="orgjson"><strong>OrgJson</strong></h3>
<ol>
<li>从JSON里put和get数据</li>
</ol>
<pre tabindex="0"><code>public static void testJsonObject() {
    //构造对象
    Person p = new Person();
    p.setName(&#34;Tom&#34;);
    p.setAge(20);
    p.setScores(Arrays.asList(60,70,80));

    //构造JSONObject对象
    JSONObject obj = new JSONObject();

    //string
    obj.put(&#34;name&#34;, p.getName());
    //int
    obj.put(&#34;age&#34;, p.getAge());
    //array
    obj.put(&#34;scores&#34;, p.getScores());
    //null
    //object.put(&#34;null&#34;, null);
    System.out.println(obj);

    System.out.println(&#34;name: &#34; + obj.getString(&#34;name&#34;));
    System.out.println(&#34;age: &#34; + obj.getInt(&#34;age&#34;));
    System.out.println(&#34;scores: &#34; + obj.getJSONArray(&#34;scores&#34;));
}
</code></pre><ol>
<li>从json文件里面读取数据并放到person对象里面</li>
</ol>
<pre tabindex="0"><code>public static void testJsonFile() {
    File file = new File(&#34;books.json&#34;);
    try (FileReader reader = new FileReader(file)) {
        //读取文件内容到JsonObject对象中
        int fileLen = (int) file.length();
        char[] chars = new char[fileLen];
        reader.read(chars);
        String s = String.valueOf(chars);
        JSONObject jsonObject = new JSONObject(s);

        //开始解析JSONObject对象
        JSONArray books = jsonObject.getJSONArray(&#34;books&#34;);
        List&lt;Book&gt; bookList = new ArrayList&lt;&gt;();
        for (Object book : books) {
            //获取单个JSONObject对象
            JSONObject bookObject = (JSONObject) book;
            Book book1 = new Book();
            book1.setAuthor(bookObject.getString(&#34;author&#34;));
            book1.setYear(bookObject.getString(&#34;year&#34;));
            book1.setTitle(bookObject.getString(&#34;title&#34;));
            book1.setPrice(bookObject.getInt(&#34;price&#34;));
            book1.setCategory(bookObject.getString(&#34;category&#34;));
            bookList.add(book1);
        }

        for(Book book:bookList)
        {
            System.out.println(book.getAuthor() + &#34;,  &#34; + book.getTitle());
        }

    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><pre tabindex="0"><code>//books.json
{
  &#34;books&#34;: [
    {
      &#34;category&#34;: &#34;COOKING&#34;,
      &#34;title&#34;: &#34;Everyday Italian&#34;,
      &#34;author&#34;: &#34;Giada De Laurentiis&#34;,
      &#34;year&#34;: &#34;2005&#34;,
      &#34;price&#34;: 30.00
    },
    {
      &#34;category&#34;: &#34;CHILDREN&#34;,
      &#34;title&#34;: &#34;Harry Potter&#34;,
      &#34;author&#34;: &#34;J K. Rowling&#34;,
      &#34;year&#34;: &#34;2005&#34;,
      &#34;price&#34;: 29.99
    },
    {
      &#34;category&#34;: &#34;WEB&#34;,
      &#34;title&#34;: &#34;Learning XML&#34;,
      &#34;author&#34;: &#34;Erik T. Ray&#34;,
      &#34;year&#34;: &#34;2003&#34;,
      &#34;price&#34;: 39.95
    }
  ]
}
</code></pre><h3 id="gson"><strong>GSON</strong></h3>
<ol>
<li>可以通过gson函数很方便的在java对象和json里面直接转换，不需要像org.json一样还要put来get去</li>
</ol>
<pre tabindex="0"><code>public static void testJsonObject() {
    //构造对象
    Person p = new Person();
    p.setName(&#34;Tom&#34;);
    p.setAge(20);
    p.setScores(Arrays.asList(60,70,80));

    //从Java对象到JSON字符串
    Gson gson = new Gson();
    String s = gson.toJson(p);
    System.out.println(s); //{&#34;name&#34;:&#34;Tom&#34;,&#34;age&#34;:20,&#34;scores&#34;:[60,70,80]}

    //从JSON字符串到Java对象
    Person p2 = gson.fromJson(s, Person.class);
    System.out.println(p2.getName());  //Tom
    System.out.println(p2.getAge());   //20
    System.out.println(p2.getScores());//[60, 70, 80]

    //调用GSON的JsonObject
    JsonObject json = gson.toJsonTree(p).getAsJsonObject(); //将整个json解析为一颗树
    System.out.println(json.get(&#34;name&#34;));  //&#34;Tom&#34;
    System.out.println(json.get(&#34;age&#34;));   //20
    System.out.println(json.get(&#34;scores&#34;));//[60,70,80]
}
</code></pre><ol>
<li>从json文件中加载数据，变成一个对象数组，操作非常简单</li>
</ol>
<pre tabindex="0"><code>public static void testJsonFile() {
    Gson gson = new Gson();
    File file = new File(&#34;books2.json&#34;);

    try (FileReader reader = new FileReader(file)) {
        List&lt;Book&gt; books = gson.fromJson(reader, new TypeToken&lt;List&lt;Book&gt;&gt;(){}.getType());

        for(Book book : books)
        {
            System.out.println(book.getAuthor() + &#34;,  &#34; + book.getTitle());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h3 id="jackson"><strong>Jackson</strong></h3>
<ol>
<li>java对象转换为json字符串</li>
</ol>
<pre tabindex="0"><code>static void testJsonObject() throws IOException {
    ObjectMapper om = new ObjectMapper();

    //构造对象
    Person p = new Person();
    p.setName(&#34;Tom&#34;);
    p.setAge(20);
    p.setScores(Arrays.asList(60,70,80));

    //将对象解析为json字符串
    String jsonStr = om.writeValueAsString(p);
    System.out.println(jsonStr);

    //从json字符串重构对象
    Person p2 = om.readValue(jsonStr, Person.class);
    System.out.println(p2.getName());
    System.out.println(p2.getAge());
    System.out.println(p2.getScores());

    //从json字符串重构为JsonNode对象
    JsonNode node = om.readTree(jsonStr);
    System.out.println(node.get(&#34;name&#34;).asText());
    System.out.println(node.get(&#34;age&#34;).asText());
    System.out.println(node.get(&#34;scores&#34;));
}
</code></pre><ol>
<li>从json文件里加载数据变成对象数组，非常简单</li>
</ol>
<pre tabindex="0"><code>static void testJsonFile() throws IOException {
    ObjectMapper om = new ObjectMapper();

    //从json文件中加载，并重构为java对象
    File json2 = new File(&#34;books2.json&#34;);
    List&lt;Book&gt; books = om.readValue(json2, new TypeReference&lt;List&lt;Book&gt;&gt;(){});
    for (Book book : books) {
        System.out.println(book.getAuthor());
        System.out.println(book.getTitle());
    }
}
</code></pre><h2 id="45-图形图像解析"><strong>4.5 图形图像解析</strong></h2>
<p>图形：Graph 矢量图，根据几何特性来画的，比如点、直线、弧线等</p>
<p>图像：Image 由像素点组成</p>
<p>图像格式：jpg, png, bmp, svg, wmf, gif, tiff 等</p>
<p>图像颜色：RGB(Red, Green, Blue)</p>
<p>javax.imageio包：</p>
<ul>
<li>
<p>javax.imageio.ImageIO</p>
<p>自动封装多种ImageReader和ImageWriter，读写图像文件</p>
<p>read 读取图片 write 写图</p>
</li>
<li>
<p>java.awt.image.BufferedImage</p>
<p>图像在内存中的表示类</p>
<p>getHeight 获取高度</p>
<p>getWidth 获取宽度</p>
</li>
</ul>
<pre tabindex="0"><code>public static void main(String[] args) throws Exception {
    readAndWrite();
    readComparison();
    cropImage(&#34;c:/temp/ecnu.jpg&#34;, &#34;c:/temp/shida.jpg&#34;, 750, 250, 700, 300, &#34;jpg&#34;, &#34;jpg&#34;);
    combineImagesHorizontally(&#34;c:/temp/ecnu.jpg&#34;,&#34;c:/temp/ecnu.jpg&#34;,&#34;jpg&#34;, &#34;c:/temp/ecnu2.jpg&#34;);
    combineImagesVertically(&#34;c:/temp/ecnu.jpg&#34;,&#34;c:/temp/ecnu.jpg&#34;,&#34;jpg&#34;, &#34;c:/temp/ecnu3.jpg&#34;);
}
</code></pre><h3 id="读和写图片"><strong>读和写图片</strong></h3>
<pre tabindex="0"><code>public static void readAndWrite() throws Exception {
    BufferedImage image = ImageIO.read(new File(&#34;c:/temp/ecnu.jpg&#34;));
    System.out.println(&#34;Height: &#34; + image.getHeight()); // 高度像素
    System.out.println(&#34;Width: &#34; + image.getWidth()); // 宽度像素
    ImageIO.write(image, &#34;png&#34;, new File(&#34;c:/temp/ecnu.png&#34;));
}
</code></pre><h3 id="切割矩形"><strong>切割矩形</strong></h3>
<pre tabindex="0"><code>/**
     * cropImage 将原始图片文件切割一个矩形，并输出到目标图片文件
     * @param fromPath 原始图片
     * @param toPath  目标图片
     * @param x       坐标起点x
     * @param y       坐标起点y
     * @param width   矩形宽度
     * @param height  矩形高度
     * @param readImageFormat  原始文件格式
     * @param writeImageFormat 目标文件格式
     * @throws Exception
     */
public static void cropImage(String fromPath, String toPath, int x, int y, int width, int height, String readImageFormat,String writeImageFormat) throws Exception {
    FileInputStream fis = null;
    ImageInputStream iis = null;
    try {
        // 读取原始图片文件
        fis = new FileInputStream(fromPath);
        Iterator&lt;ImageReader&gt; it = ImageIO.getImageReadersByFormatName(readImageFormat);
        ImageReader reader = it.next();
        iis = ImageIO.createImageInputStream(fis);
        reader.setInput(iis, true);

        // 定义一个矩形 并放入切割参数中
        ImageReadParam param = reader.getDefaultReadParam();
        Rectangle rect = new Rectangle(x, y, width, height);
        param.setSourceRegion(rect);

        //从源文件读取一个矩形大小的图像
        BufferedImage bi = reader.read(0, param);

        //写入到目标文件
        ImageIO.write(bi, writeImageFormat, new File(toPath));
    } finally {
        fis.close();
        iis.close();
    }
}
</code></pre><p>效果如下：</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211115142403.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211115142445.png" alt=""></p>
<h3 id="横向拼接"><strong>横向拼接</strong></h3>
<pre tabindex="0"><code>/**
     * 横向拼接两张图片，并写入到目标文件
     * 拼接的本质，就是申请一个大的新空间，然后将原始的图片像素点拷贝到新空间，最后保存
     * @param firstPath 第一张图片的路径
     * @param secondPath    第二张图片的路径
     * @param imageFormat   拼接生成图片的格式
     * @param toPath    目标图片的路径
     */
public static void combineImagesHorizontally(String firstPath, String secondPath,String imageFormat, String toPath){
    try {
        //读取第一张图片
        File  first  =  new  File(firstPath);
        BufferedImage  imageOne = ImageIO.read(first);
        int  width1  =  imageOne.getWidth();//图片宽度
        int  height1  =  imageOne.getHeight();//图片高度
        //从第一张图片中读取RGB
        int[]  firstRGB  =  new  int[width1*height1];
        firstRGB  =  imageOne.getRGB(0,0,width1,height1,firstRGB,0,width1);

        //对第二张图片做同样的处理
        File  second  =  new  File(secondPath);
        BufferedImage  imageTwo  =  ImageIO.read(second);
        int width2 = imageTwo.getWidth();
        int height2 = imageTwo.getHeight();
        int[]   secondRGB  =  new  int[width2*height2];
        secondRGB  =  imageTwo.getRGB(0,0,width2,height2,secondRGB,0,width2);

        //生成新图片
        int height3 = (height1&gt;height2)?height1:height2; //挑选高度大的，作为目标文件的高度
        int width3  = width1 + width2;                   //宽度，两张图片相加
        BufferedImage  imageNew  =  new  BufferedImage(width3,height3,BufferedImage.TYPE_INT_RGB);

        //设置左半部分的RGB 从(0,0) 开始
        imageNew.setRGB(0,0,width1,height1,firstRGB,0,width1);
        //设置右半部分的RGB 从(width1, 0) 开始
        imageNew.setRGB(width1,0,width2,height2,secondRGB,0,width2);

        //保存图片
        ImageIO.write(imageNew,  imageFormat,  new  File(toPath));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>效果如下</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211115142839.png" alt=""></p>
<h3 id="纵向拼接"><strong>纵向拼接</strong></h3>
<pre tabindex="0"><code>/**
     * 纵向拼接图片（两张）
     * 拼接的本质，就是申请一个大的新空间，然后将原始的图片像素点拷贝到新空间，最后保存
     * @param firstPath 读取的第一张图片
     * @param secondPath    读取的第二张图片
     * @param imageFormat 图片写入格式
     * @param toPath    图片写入路径
     */
public static void combineImagesVertically(String firstPath, String secondPath,String imageFormat, String toPath){
    try {
        //读取第一张图片
        File  first  =  new  File(firstPath);
        BufferedImage  imageOne = ImageIO.read(first);
        int  width1  =  imageOne.getWidth();//图片宽度
        int  height1  =  imageOne.getHeight();//图片高度
        //从图片中读取RGB
        int[]  firstRGB  =  new  int[width1*height1];
        firstRGB  =  imageOne.getRGB(0,0,width1,height1,firstRGB,0,width1);

        //对第二张图片做相同的处理
        File  second  =  new  File(secondPath);
        BufferedImage  imageTwo  =  ImageIO.read(second);
        int width2 = imageTwo.getWidth();
        int height2 = imageTwo.getHeight();
        int[]   secondRGB  =  new  int[width2*height2];
        secondRGB  =  imageTwo.getRGB(0,0,width2,height2,secondRGB,0,width2);

        //生成新图片
        int width3 = (width1&gt;width2)?width1:width2; //挑选宽度大的，作为目标文件的宽度
        int height3 = height1+height2;              //高度，两张图片相加
        BufferedImage  imageNew  =  new  BufferedImage(width3,height3,BufferedImage.TYPE_INT_RGB);
        //设置上半部分的RGB 从(0,0) 开始
        imageNew.setRGB(0,0,width1,height1,firstRGB,0,width1);
        //设置下半部分的RGB 从(0, height1) 开始
        imageNew.setRGB(0,height1,width2,height2,secondRGB,0,width2);

        //保存图片
        ImageIO.write(imageNew, imageFormat, new File(toPath));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h3 id="应用-验证码的生成"><strong>应用 验证码的生成</strong></h3>
<p>题目要求</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211115143206.png" alt=""></p>
<pre tabindex="0"><code>public class ValidateCodeTest {

    //没有1 I L 0 o
    static char[] codeSequence = { &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;J&#39;, &#39;K&#39;, &#39;M&#39;, &#39;N&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;,
            &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; };
    static int charNum = codeSequence.length;

    public static void main(String[] a) throws IOException
    {
        generateCode(&#34;c:/temp/code.jpg&#34;);
    }

    public static void generateCode(String filePath) throws IOException {
        // 首先定义验证码图片框
        int width = 80; // 验证码图片的宽度
        int height = 32; // 验证码图片的高度
        BufferedImage buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        //定义图片上的图形和干扰线
        Graphics2D gd = buffImg.createGraphics();
        gd.setColor(Color.LIGHT_GRAY);   // 将图像填充为浅灰色
        gd.fillRect(0, 0, width, height);
        gd.setColor(Color.BLACK);        // 画边框。
        gd.drawRect(0, 0, width - 1, height - 1);
        // 随机产生16条灰色干扰线，使图像中的认证码不易识别
        gd.setColor(Color.gray);
        // 创建一个随机数生成器类   用于随机产生干扰线
        Random random = new Random();
        for (int i = 0; i &lt; 16; i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            gd.drawLine(x, y, x + xl, y + yl);
        }

        //计算字的位置坐标
        int codeCount = 4; // 字符个数
        int fontHeight; // 字体高度
        int codeX; // 第一个字符的x坐标，因为后面的字符坐标依次递增，所以它们的x轴值是codeX的倍数
        int codeY; // 验证字符的y坐标，因为并排所以值一样
        // width-4 除去左右多余的位置，使验证码更加集中显示，减得越多越集中。
        // codeCount+1 //等比分配显示的宽度，包括左右两边的空格
        codeX = (width - 4) / (codeCount + 1); //第一个字母的起始位置
        fontHeight = height - 10;  // height - 10 高度中间区域显示验证码
        codeY = height - 7;

        // 创建字体，字体的大小应该根据图片的高度来定。
        Font font = new Font(&#34;Fixedsys&#34;, Font.PLAIN, fontHeight);
        gd.setFont(font);

        // 随机产生codeCount数字的验证码。
        for (int i = 0; i &lt; codeCount; i++) {
            // 每次随机拿一个字母，赋予随机的颜色
            String strRand = String.valueOf(codeSequence[random.nextInt(charNum)]);
            int red = random.nextInt(255);
            int green = random.nextInt(255);
            int blue = random.nextInt(255);
            gd.setColor(new Color(red,green,blue));
            //把字放到图片上!!!
            gd.drawString(strRand, (i + 1) * codeX, codeY);
        }

        ImageIO.write(buffImg, &#34;jpg&#34;, new File(filePath));
    }
}
</code></pre><h3 id="应用-统计图生成"><strong>应用 统计图生成</strong></h3>
<p>包括柱状图、饼图、折线图</p>
<pre tabindex="0"><code>public static void main(String[] args) {
    writeBar(&#34;c:/temp/bar.jpg&#34;); // 柱状图
    writePie(&#34;c:/temp/pie.jpg&#34;); // 饼图
    writeLine(&#34;c:/temp/line.jpg&#34;);// 折线图
}

public static StandardChartTheme getChineseTheme()
{
    StandardChartTheme chineseTheme = new StandardChartTheme(&#34;CN&#34;);
    chineseTheme.setExtraLargeFont(new Font(&#34;隶书&#34;, Font.BOLD, 20));
    chineseTheme.setRegularFont(new Font(&#34;宋书&#34;, Font.PLAIN, 15));
    chineseTheme.setLargeFont(new Font(&#34;宋书&#34;, Font.PLAIN, 15));
    return chineseTheme;
}
</code></pre><p>柱状图</p>
<pre tabindex="0"><code>public static void writeBar(String fileName) {
    DefaultCategoryDataset dataset = new DefaultCategoryDataset();
    dataset.addValue(11, &#34;&#34;, &#34;第一季度&#34;);
    dataset.addValue(41, &#34;&#34;, &#34;第二季度&#34;);
    dataset.addValue(51, &#34;&#34;, &#34;第三季度&#34;);
    dataset.addValue(4, &#34;&#34;, &#34;第四季度&#34;);

    // PlotOrientation.HORIZONTAL横向 PlotOrientation.VERTICAL 竖向
    // 引入中文主题样式
    ChartFactory.setChartTheme(getChineseTheme());
    JFreeChart chart = ChartFactory.createBarChart3D(&#34;柱状图&#34;, &#34;2018年&#34;, &#34;产品总量&#34;, dataset, PlotOrientation.VERTICAL,
                                                     false, false, false);

    try {
        ChartUtilities.saveChartAsJPEG(new File(fileName), chart, 600, 300);
    } catch (IOException e) {
        e.printStackTrace();
    }

}
</code></pre><p>饼图</p>
<pre tabindex="0"><code>public static void writePie(String fileName) {
    DefaultPieDataset pds = new DefaultPieDataset();
    pds.setValue(&#34;C人数&#34;, 100);
    pds.setValue(&#34;C++人数&#34;, 200);
    pds.setValue(&#34;Java人数&#34;, 300);
    try {
        ChartFactory.setChartTheme(getChineseTheme());
        JFreeChart chart = ChartFactory.createPieChart(&#34;饼图&#34;, pds);

        ChartUtilities.saveChartAsJPEG(new File(fileName), chart, 600, 300);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>折线图，双折线图</p>
<pre tabindex="0"><code>public static void writeLine(String fileName) {
    DefaultCategoryDataset lines = new DefaultCategoryDataset();
    //第一条线
    lines.addValue(100, &#34;Java核心技术&#34;, &#34;1月&#34;);
    lines.addValue(200, &#34;Java核心技术&#34;, &#34;2月&#34;);
    lines.addValue(400, &#34;Java核心技术&#34;, &#34;3月&#34;);
    lines.addValue(500, &#34;Java核心技术&#34;, &#34;4月&#34;);

    //第二条线
    lines.addValue(100, &#34;Java核心技术(进阶)&#34;, &#34;1月&#34;);
    lines.addValue(400, &#34;Java核心技术(进阶)&#34;, &#34;2月&#34;);
    lines.addValue(900, &#34;Java核心技术(进阶)&#34;, &#34;3月&#34;);
    try {
        ChartFactory.setChartTheme(getChineseTheme());
        JFreeChart chart = ChartFactory.createLineChart(&#34;折线图&#34;, &#34;时间&#34;, &#34;人数&#34;, lines);
        ChartUtilities.saveChartAsJPEG(new File(fileName), chart, 600, 300);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="46-条形码和二维码解析"><strong>4.6 条形码和二维码解析</strong></h2>
<p>两个处理二维码的第三方库</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116105235.png" alt=""></p>
<p>只要我们把内容提供给zebra crossing，他就会自动生成好二维码，也可以解析</p>
<p>下面是生成和解析百度网址二维码的例子，我们需要改动的只有file name和content内容</p>
<pre tabindex="0"><code>public class QRCodeTest {
    /*
     * 定义二维码的宽高
     */
    private static int WIDTH = 300;
    private static int HEIGHT = 300;
    private static String FORMAT = &#34;png&#34;;//二维码格式

    //生成二维码
    public static void generateQRCode(File file, String content) {
        //定义二维码参数
        Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;&gt;();

        hints.put(EncodeHintType.CHARACTER_SET, &#34;utf-8&#34;);//设置编码
        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);//设置容错等级
        hints.put(EncodeHintType.MARGIN, 2);//设置边距默认是5

        try {
            BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, WIDTH, HEIGHT, hints);
            Path path = file.toPath();
            MatrixToImageWriter.writeToPath(bitMatrix, FORMAT, path);//写到指定路径下

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    //读取二维码
    public static void readQrCode(File file) {
        MultiFormatReader reader = new MultiFormatReader();
        try {
            BufferedImage image = ImageIO.read(file);
            BinaryBitmap binaryBitmap = new BinaryBitmap(new HybridBinarizer(new BufferedImageLuminanceSource(image)));
            Map&lt;DecodeHintType, Object&gt; hints = new HashMap&lt;&gt;();
            hints.put(DecodeHintType.CHARACTER_SET, &#34;utf-8&#34;);//设置编码
            Result result = reader.decode(binaryBitmap, hints);
            System.out.println(&#34;解析结果:&#34; + result.toString());
            System.out.println(&#34;二维码格式:&#34; + result.getBarcodeFormat());
            System.out.println(&#34;二维码文本内容:&#34; + result.getText());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        generateQRCode(new File(&#34;2dcode.png&#34;), &#34;https://www.baidu.com&#34;);
        readQrCode(new File(&#34;2dcode.png&#34;));
        //readQrCode(new File(&#34;2dcode.jpg&#34;));
    }
}
</code></pre><p>第二个第三方库barcode4j</p>
<p>它只能生成二维码，不能解析二维码</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116110031.png" alt=""></p>
<p>另外，要想使用这两个包，必须在pom.xml里面引入配置文件</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
    &lt;artifactId&gt;core&lt;/artifactId&gt;
    &lt;version&gt;3.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
    &lt;artifactId&gt;javase&lt;/artifactId&gt;
    &lt;version&gt;3.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/net.sf.barcode4j/barcode4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.barcode4j&lt;/groupId&gt;
    &lt;artifactId&gt;barcode4j&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.avalon.framework/avalon-framework-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.avalon.framework&lt;/groupId&gt;
    &lt;artifactId&gt;avalon-framework-api&lt;/artifactId&gt;
    &lt;version&gt;4.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="47-docx文件解析"><strong>4.7 DOCX文件解析</strong></h2>
<p>word2003以前文档格式是doc，文档格式不公开</p>
<p>word2007以后文档格式是docx，遵循xml路线，文档格式公开</p>
<p>常见功能：docx解析，docx生成</p>
<p>java没办法处理docx，用到的第三方库，我们主要用到POI</p>
<p>POI是一个纯java的工具包，不需要引入第三方的依赖</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116110757.png" alt=""></p>
<p>这一节的例子：</p>
<ol>
<li>
<p>读取docx文件的text</p>
</li>
<li>
<p>读取docx文件里的图片</p>
</li>
<li>
<p>写入图片</p>
</li>
<li>
<p>读取docx文件里的表格</p>
</li>
<li>
<p>将数据写入docx文件的表格里</p>
</li>
<li>
<p>文档模板替换功能，套打功能</p>
<p>就是把文件里占位符换成真实的数据</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116112102.png" alt=""></p>
</li>
</ol>
<h2 id="48-表格文件的处理"><strong>4.8 表格文件的处理</strong></h2>
<p>xls和xlxs文件：sheet，行，列，单元格</p>
<p>csv文件</p>
<p>用到的第三方包：POI</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116122530.png" alt=""></p>
<h3 id="写xlsx文件"><strong>写xlsx文件</strong></h3>
<pre tabindex="0"><code>public static void writeXLSXFile() throws IOException
{

    String excelFileName = &#34;Test.xlsx&#34;;// name of excel file
    String sheetName = &#34;Sheet1&#34;;// name of sheet

    XSSFWorkbook wb = new XSSFWorkbook();
    XSSFSheet sheet = wb.createSheet(sheetName);

    // iterating r number of rows
    for (int r = 0; r &lt; 5; r++)
    {
        XSSFRow row = sheet.createRow(r);

        // iterating c number of columns
        for (int c = 0; c &lt; 5; c++)
        {
            XSSFCell cell = row.createCell(c);

            cell.setCellValue(&#34;Cell &#34; + r + &#34; &#34; + c);
        }
    }

    FileOutputStream fileOut = new FileOutputStream(excelFileName);

    // write this workbook to an Outputstream.
    wb.write(fileOut);
    fileOut.flush();
    fileOut.close();
}
</code></pre><h3 id="读xlsx文件"><strong>读xlsx文件</strong></h3>
<pre tabindex="0"><code>public static void readXLSXFile() throws IOException
{
    InputStream ExcelFileToRead = new FileInputStream(&#34;Test.xlsx&#34;);
    XSSFWorkbook wb = new XSSFWorkbook(ExcelFileToRead);

    XSSFSheet sheet = wb.getSheetAt(0);
    XSSFRow row;
    XSSFCell cell;

    Iterator rows = sheet.rowIterator();

    while (rows.hasNext())
    {
        row = (XSSFRow) rows.next();
        Iterator cells = row.cellIterator();
        while (cells.hasNext())
        {
            cell = (XSSFCell) cells.next();

            if (cell.getCellType() == XSSFCell.CELL_TYPE_STRING)
            {
                System.out.print(cell.getStringCellValue() + &#34; &#34;);
            }
            else if (cell.getCellType() == XSSFCell.CELL_TYPE_NUMERIC)
            {
                System.out.print(cell.getNumericCellValue() + &#34; &#34;);
            }
            else
            {
                // U Can Handel Boolean, Formula, Errors
            }
        }
        System.out.println();
    }

}
</code></pre><h3 id="读csv文件"><strong>读csv文件</strong></h3>
<p>以逗号分隔的文本文件，可以用excel打开变成表格</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116131114.png" alt=""></p>
<p>根据索引值获取csv文件数据</p>
<pre tabindex="0"><code>public static void readCSVWithIndex() throws Exception {
    Reader in = new FileReader(&#34;c:/temp/score.csv&#34;);
    Iterable&lt;CSVRecord&gt; records = CSVFormat.EXCEL.parse(in);
    for (CSVRecord record : records) {
        System.out.println(record.get(0)); //0 代表第一列
    }
}
</code></pre><p>根据列名来获取列，在读入的时候给每个列取个名字</p>
<pre tabindex="0"><code>public static void readCSVWithName() throws Exception {
    Reader in = new FileReader(&#34;c:/temp/score.csv&#34;);
    Iterable&lt;CSVRecord&gt; records = CSVFormat.RFC4180.withHeader(&#34;Name&#34;, &#34;Subject&#34;, &#34;Score&#34;).parse(in);
    for (CSVRecord record : records) {
        System.out.println(record.get(&#34;Subject&#34;));
    }
}
</code></pre><h3 id="写csv文件"><strong>写csv文件</strong></h3>
<pre tabindex="0"><code>public static void writeCSV() throws Exception {
    try (CSVPrinter printer = new CSVPrinter(new FileWriter(&#34;person.csv&#34;), CSVFormat.EXCEL)) {
        printer.printRecord(&#34;id&#34;, &#34;userName&#34;, &#34;firstName&#34;, &#34;lastName&#34;, &#34;birthday&#34;);
        printer.printRecord(1, &#34;john73&#34;, &#34;John&#34;, &#34;Doe&#34;, LocalDate.of(1973, 9, 15));
        printer.println();  //空白行
        printer.printRecord(2, &#34;mary&#34;, &#34;Mary&#34;, &#34;Meyer&#34;, LocalDate.of(1985, 3, 29));
    } catch (IOException ex) {
        ex.printStackTrace();
    }
}
</code></pre><h2 id="49-pdf文件的处理"><strong>4.9 PDF文件的处理</strong></h2>
<p>portable document 便携式文档格式</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116131827.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116131931.png" alt=""></p>
<h3 id="抽取pdf的文本"><strong>抽取pdf的文本</strong></h3>
<pre tabindex="0"><code>public static void main(String[] args){

    File pdfFile = new File(&#34;simple.pdf&#34;);
    PDDocument document = null;
    try
    {
        document=PDDocument.load(pdfFile);

        AccessPermission ap = document.getCurrentAccessPermission();
        if (!ap.canExtractContent())
        {
            throw new IOException(&#34;你没有权限抽取文本&#34;);
        }
        // 获取页码
        int pages = document.getNumberOfPages();

        // 读文本内容
        PDFTextStripper stripper=new PDFTextStripper();
        // 设置按顺序输出
        stripper.setSortByPosition(true);
        stripper.setStartPage(1);  //起始页
        stripper.setEndPage(pages);//结束页
        String content = stripper.getText(document);
        System.out.println(content);
    }
    catch(Exception e)
    {
        System.out.println(e);
    }
}
</code></pre><h3 id="写pdf"><strong>写pdf</strong></h3>
<pre tabindex="0"><code>public static void main(String[] args) {
    createHelloPDF();
}
public static void createHelloPDF() {
    PDDocument doc = null;
    PDPage page = null;

    try {
        doc = new PDDocument();
        page = new PDPage();
        doc.addPage(page);
        PDFont font = PDType1Font.HELVETICA_BOLD;
        PDPageContentStream content = new PDPageContentStream(doc, page);
        content.beginText();
        content.setFont(font, 12);
        content.moveTextPositionByAmount(100, 700);
        content.showText(&#34;hello world&#34;);

        content.endText();
        content.close();
        doc.save(&#34;test.pdf&#34;);
        doc.close();
    } catch (Exception e) {
        System.out.println(e);
    }
}
</code></pre><h3 id="合并两个pdf"><strong>合并两个pdf</strong></h3>
<pre tabindex="0"><code>private static final Log LOG = LogFactory.getLog(NewMergePdfs.class);

public static void main(String[] a) throws Exception
{
    merge();
}

public static void merge() throws Exception
{
    FileOutputStream  fos = new FileOutputStream(new File(&#34;merge.pdf&#34;));

    ByteArrayOutputStream mergedPDFOutputStream = null;
    File file1 = new File(&#34;sample1.pdf&#34;);
    File file2 = new File(&#34;sample2.pdf&#34;);

    List&lt;InputStream&gt; sources = new ArrayList&lt;InputStream&gt;();

    try
    {
        sources.add(new FileInputStream(file1));
        sources.add(new FileInputStream(file2));

        mergedPDFOutputStream = new ByteArrayOutputStream();

        //设定来源和目标
        PDFMergerUtility pdfMerger = new PDFMergerUtility();
        pdfMerger.addSources(sources);
        pdfMerger.setDestinationStream(mergedPDFOutputStream);

        //设置合并选项
        PDDocumentInformation pdfDocumentInfo = new PDDocumentInformation();
        pdfMerger.setDestinationDocumentInformation(pdfDocumentInfo);

        //合并
        pdfMerger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());

        fos.write(mergedPDFOutputStream.toByteArray());
        fos.close();
    }
    catch (Exception e)
    {
        throw new IOException(&#34;PDF merge problem&#34;, e);
    }
    finally
    {
        for (InputStream source : sources)
        {
            IOUtils.closeQuietly(source);
        }
        IOUtils.closeQuietly(mergedPDFOutputStream);
        IOUtils.closeQuietly(fos);
    }
}
</code></pre><h3 id="删除一页pdf"><strong>删除一页pdf</strong></h3>
<pre tabindex="0"><code>public static void main(String[] args) throws Exception {
    File file = new File(&#34;merge.pdf&#34;);
    PDDocument document = PDDocument.load(file);

    int noOfPages = document.getNumberOfPages();
    System.out.println(&#34;total pages: &#34; + noOfPages);

    // 删除第1页
    document.removePage(1);  // 页码索引从0开始算

    System.out.println(&#34;page removed&#34;);

    // 另存为新文档
    document.save(&#34;merge2.pdf&#34;);

    document.close();
}
</code></pre><h3 id="xdocreport类"><strong>XdocReport类</strong></h3>
<p>主要用途是将docx文档转换为pdf/html&hellip;.</p>
<pre tabindex="0"><code>public class XDocReportTest {

    public static void main(String[] args) throws Exception {
        XWPFDocument doc = new XWPFDocument(new FileInputStream(&#34;template.docx&#34;));// docx
        PdfOptions options = PdfOptions.create();
        options.fontProvider(new IFontProvider() {
            // 设置中文字体
            public Font getFont(String familyName, String encoding, float size, int style, Color color) {
                try {
                    BaseFont bfChinese = BaseFont.createFont(
                            &#34;C:\\Program Files (x86)\\Microsoft Office\\root\\VFS\\Fonts\\private\\STSONG.TTF&#34;,
                            BaseFont.IDENTITY_H, BaseFont.EMBEDDED);
                    Font fontChinese = new Font(bfChinese, size, style, color);
                    if (familyName != null)
                        fontChinese.setFamily(familyName);
                    return fontChinese;
                } catch (Throwable e) {
                    e.printStackTrace();
                    return ITextFontRegistry.getRegistry().getFont(familyName, encoding, size, style, color);
                }
            }
        });
        PdfConverter.getInstance().convert(doc, new FileOutputStream(&#34;template.pdf&#34;), options);// pdf
    }
}
</code></pre><h1 id="第五章-java多线程和并发线程"><strong>第五章 java多线程和并发线程</strong></h1>
<p>串行程序，程序只能在单核上运行，无法利用多个cpu</p>
<p>并行程序，程序可以利用多个计算核运行</p>
<h2 id="51-多线程的生命周期"><strong>5.1 多线程的生命周期</strong></h2>
<h3 id="java多线程的创建"><strong>java多线程的创建</strong></h3>
<p>有两种方法</p>
<p>线程继承（extends）java.lang.Thread类，实现run方法</p>
<pre tabindex="0"><code>public class Thread1 extends Thread{
    public void run()
    {
        System.out.println(&#34;hello&#34;);
    }
    public static void main(String[] a)
    {
        new Thread1().start();
    }
}
</code></pre><p>线程实现（implement）java.lang.Runnable类，实现run方法</p>
<p>runnable是java四个主要接口之一：Clonable/Comparable/Serializable/Runnable</p>
<pre tabindex="0"><code>public class Thread2 implements Runnable{
    public void run()
    {
        System.out.println(&#34;hello&#34;);
    }
    public static void main(String[] a)
    {
        new Thread(new Thread2()).start();
    }
}
</code></pre><h3 id="java多线程的启动"><strong>java多线程的启动</strong></h3>
<p>两种创建方式不同，启动方式也是不同的</p>
<p>多个线程启动，其启动的先后顺序是随机的</p>
<p>1.通过继承Thread类创建的线程</p>
<p>start方法，会自动以新线程调用run方法，请注意要是直接调用run，会变成串行执行</p>
<p>一个线程对象不能多次start，会报错，多个线程对象都start后，哪一个线程先执行完全由操作系统/JVM来主导</p>
<pre tabindex="0"><code>public class ThreadDemo1
{
    public static void main(String args[]) throws Exception
    {
        new TestThread1().start();
        while(true)
        {
            System.out.println(&#34;main thread is running&#34;);
            Thread.sleep(1000);
        }
    }
}

class TestThread1 extends Thread
{
    public void run()
    {
        while(true)
        {
            System.out.println(&#34; TestThread1 is running&#34;);
            try {
                Thread.sleep(1000); //1000毫秒
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>2.通过实现Runnable类创建的线程</p>
<p>注意Runnable对象必须放在一个Thread类中才能运行，不能直接对一个Runnable对象执行start方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ThreadDemo3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">args</span><span class="o">[]</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">TestThread3</span><span class="w"> </span><span class="n">tt</span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TestThread3</span><span class="p">();</span><span class="c1">//创建TestThread类的一个实例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//new TestThread3().start();会报错</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">tt</span><span class="p">);</span><span class="c1">//创建一个Thread类的实例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">t</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="c1">//使线程进入Runnable状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;main thread is running&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">TestThread3</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Runnable</span><span class="w"> </span><span class="c1">//extends Thread</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="s">&#34; is running&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="java多线程的结束"><strong>java多线程的结束</strong></h3>
<p>线程无需关闭，只要run执行完之后就自动结束了</p>
<p>main函数线程可能早于新线程结束，整个程序的终止是等所有线程都中止</p>
<h2 id="52-多线程信息共享"><strong>5.2 多线程信息共享</strong></h2>
<p>粗粒度：子线程与子线程之间和main线程之间缺乏交流</p>
<p>细粒度：线程之间有信息交流通讯（通过共享变量达到信息共享，有两种方法：static变量/同一个Runnable类的成员变量）</p>
<p>static变量实例</p>
<pre tabindex="0"><code>
public class ThreadDemo0
{
    public static void main(String [] args)
    {
        new TestThread0().start();
        new TestThread0().start();
        new TestThread0().start();
        new TestThread0().start();
    }
}
class TestThread0 extends Thread
{
    //private int tickets=100;           //每个线程卖100张，没有共享
    private static int tickets=100;  //static变量是共享的，所有的线程共享
    public void run()
    {
        while(true)
        {
            if(tickets&gt;0)
            {
                System.out.println(Thread.currentThread().getName() +
                &#34; is selling ticket &#34; + tickets);
                tickets = tickets - 1;
            }
            else
            {
                break;
            }
        }
    }
}
</code></pre><p>同一个Runnable类的成员变量实例</p>
<p>注意TestThread1只被创建了一次，就是t，而new Thread只是把同一个t包装成不同的线程对象启动</p>
<pre tabindex="0"><code>
public class ThreadDemo1
{
    public static void main(String [] args)
    {
        TestThread1 t=new TestThread1();
        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
    }
}
class TestThread1 implements Runnable
{
    private int tickets=100;
    public void run()
    {
        while(true)
        {
            if(tickets&gt;0)
            {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                tickets--;
                System.out.println(Thread.currentThread().getName() +&#34; is selling ticket &#34; + tickets);
            }
            else
            {
                break;
            }

        }
    }
}
</code></pre><p>多线程信息共享问题：</p>
<p>1.工作缓存副本</p>
<p>2.关键步骤缺乏加锁限制</p>
<p>缓存副本解决方法：volatile关键字修饰变量，可以让所有线程都立即看到这个值的变化</p>
<pre tabindex="0"><code>public class ThreadDemo2
{
    public static void main(String args[]) throws Exception
    {
        TestThread2 t = new TestThread2();
        t.start();
        Thread.sleep(2000);
        t.flag = false;
        System.out.println(&#34;main thread is exiting&#34;);
    }
}

class TestThread2 extends Thread
{
    //boolean flag = true;   //子线程不会停止
    volatile boolean flag = true;  //用volatile修饰的变量可以及时在各线程里面通知
    public void run()
    {
        int i=0;
        while(flag)
        {i++;}
        System.out.println(&#34;test thread3 is exiting&#34;);
    }
}
</code></pre><p>加锁限制解决方法：</p>
<p><strong>互斥</strong>指某一个线程运行一个代码段，其他线程不能运行</p>
<p><strong>同步</strong>指多个线程的运行，必须按照某一种规定的先后顺序，是互斥的特例</p>
<p>被<strong>synchronized关键字</strong>修饰的代码块或函数，只能一个线程进入</p>
<pre tabindex="0"><code>
public class ThreadDemo3 {
    public static void main(String[] args) {
        TestThread3 t = new TestThread3();
        new Thread(t, &#34;Thread-0&#34;).start();
        new Thread(t, &#34;Thread-1&#34;).start();
        new Thread(t, &#34;Thread-2&#34;).start();
        new Thread(t, &#34;Thread-3&#34;).start();
    }
}

class TestThread3 implements Runnable {
    private volatile int tickets = 10; // 多个 线程在共享的

    public void run() {
        while (true) {
            sale();
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
            if (tickets &lt;= 0) {break;}
        }
    }

    public synchronized void sale() { // 同步函数
        if (tickets &gt; 0) {
            System.out.println(Thread.currentThread().getName() + &#34; is saling ticket &#34; + tickets--);
        }
    }
}
</code></pre><pre tabindex="0"><code>//OUTPUT

Thread-0 is saling ticket 10
Thread-3 is saling ticket 9
Thread-2 is saling ticket 8
Thread-1 is saling ticket 7
Thread-1 is saling ticket 6
Thread-2 is saling ticket 5
Thread-3 is saling ticket 4
Thread-0 is saling ticket 3
Thread-3 is saling ticket 2
Thread-2 is saling ticket 1
</code></pre><h2 id="53-多线程管理"><strong>5.3 多线程管理</strong></h2>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211017161319.png" alt=""></p>
<p>线程的阻塞和唤醒</p>
<pre tabindex="0"><code>sleep，时间一到，自己会醒来
–wait/notify/notifyAll，等待，需要别人来唤醒
– join，等待另外一个线程结束
– interrupt，向另外一个线程发送中断信号，该线程收到信号，会
触发InterruptedException(可解除阻塞)，并进行下一步处
</code></pre><h2 id="55-java并发框架-executor"><strong>5.5 java并发框架 executor</strong></h2>
<p>java并行模式</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116152521.png" alt=""></p>
<p>线程组的管理，就是有很多的线程类的时候，怎么把他放在一起进行管理</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116152631.png" alt=""></p>
<p>线程组如何管理线程</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211117101250.png" alt=""></p>
<p>但线程组并没有解决高耦合的问题，所以我们引入了框架</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116153242.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116153257.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211117102057.png" alt=""></p>
<p>下面看代码</p>
<p><strong>main函数</strong>里就是两件事，创建服务器，创建100个任务</p>
<p>现在可以不知道这个任务具体指什么，但我们先创建出来</p>
<pre tabindex="0"><code>public class Main {

    public static void main(String[] args) throws InterruptedException {
        // 创建一个执行服务器
        Server server=new Server();

        // 创建100个任务，并发给执行器，等待完成
        for (int i=0; i&lt;100; i++){
            Task task=new Task(&#34;Task &#34;+i);
            Thread.sleep(10);
            server.submitTask(task);
        }
        server.endServer();
    }
}
</code></pre><p><strong>服务器端</strong></p>
<p>submittask是我们外界创建任务时调用的，向线程池提交任务</p>
<p>其中executor.execute(task); //执行</p>
<pre tabindex="0"><code>public class Server {

    //线程池
    private ThreadPoolExecutor executor;

    public Server(){
        executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
        //executor=(ThreadPoolExecutor)Executors.newFixedThreadPool(5);
    }

    //向线程池提交任务
    public void submitTask(Task task){
        System.out.printf(&#34;Server: A new task has arrived\n&#34;);
        executor.execute(task); //执行  无返回值

        System.out.printf(&#34;Server: Pool Size: %d\n&#34;,executor.getPoolSize());
        System.out.printf(&#34;Server: Active Count: %d\n&#34;,executor.getActiveCount());
        System.out.printf(&#34;Server: Completed Tasks: %d\n&#34;,executor.getCompletedTaskCount());
    }

    public void endServer() {
        executor.shutdown();
    }
}
</code></pre><p><strong>任务端</strong></p>
<p>主要的任务代码写在这里</p>
<pre tabindex="0"><code>package executor.example1;

import java.util.Date;
import java.util.concurrent.TimeUnit;
/**
 * Task 任务类
 * @author Tom
 *
 */
public class Task implements Runnable {

    private String name;

    public Task(String name){
        this.name=name;
    }

    public void run() {
        try {
            Long duration=(long)(Math.random()*1000);
            System.out.printf(&#34;%s: Task %s: Doing a task during %d seconds\n&#34;,Thread.currentThread().getName(),name,duration);
            Thread.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.printf(&#34;%s: Task %s: Finished on: %s\n&#34;,Thread.currentThread().getName(),name,new Date());
    }
}
</code></pre><p>再看一个复杂的例子</p>
<p>0-1000的数求和</p>
<p>分成10个任务，线程池固定只有4个线程</p>
<pre tabindex="0"><code>public class SumTest {

    public static void main(String[] args) {

        // 执行线程池
        ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newFixedThreadPool(4);
        List&lt;Future&lt;Integer&gt;&gt; resultList=new ArrayList&lt;&gt;();

        //统计1-1000总和，分成10个任务计算，提交任务
        for (int i=0; i&lt;10; i++){
            SumTask calculator=new SumTask(i*100+1, (i+1)*100);
            Future&lt;Integer&gt; result=executor.submit(calculator);
            resultList.add(result);
        }

        // 每隔50毫秒，轮询等待10个任务结束
        do {
            System.out.printf(&#34;Main: 已经完成多少个任务: %d\n&#34;,executor.getCompletedTaskCount());
            for (int i=0; i&lt;resultList.size(); i++) {
                Future&lt;Integer&gt; result=resultList.get(i);
                System.out.printf(&#34;Main: Task %d: %s\n&#34;,i,result.isDone());
            }
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } while (executor.getCompletedTaskCount()&lt;resultList.size());

        // 所有任务都已经结束了，综合计算结果
        int total = 0;
        for (int i=0; i&lt;resultList.size(); i++) {
            Future&lt;Integer&gt; result=resultList.get(i);
            Integer sum=null;
            try {
                sum=result.get();
                total = total + sum;
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
        System.out.printf(&#34;1-1000的总和:&#34; + total);

        // 关闭线程池
        executor.shutdown();
    }
}
</code></pre><p>任务类</p>
<p>继承了callable的方法，不同的是把run()写为call()，并且call()是有返回值的</p>
<pre tabindex="0"><code>public class SumTask implements Callable&lt;Integer&gt; {
    //定义每个线程计算的区间
    private int startNumber;
    private int endNumber;

    public SumTask(int startNumber, int endNumber){
        this.startNumber=startNumber;
        this.endNumber=endNumber;
    }

    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for(int i=startNumber; i&lt;=endNumber; i++)
        {
            sum = sum + i;
        }

        Thread.sleep(new Random().nextInt(1000));

        System.out.printf(&#34;%s: %d\n&#34;,Thread.currentThread().getName(),sum);
        return sum;
    }
}
</code></pre><h2 id="56-fork-join"><strong>5.6 Fork-join</strong></h2>
<p>这是一种分治编程</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211117104516.png" alt=""></p>
<p>下面例子用fork-join来求一个数组和</p>
<p>sumtask实现了RecursiveTask，一个可递归的任务，必须实现compute()方法</p>
<pre tabindex="0"><code>//分任务求和
public class SumTask extends RecursiveTask&lt;Long&gt; {

    private int start;
    private int end;

    public SumTask(int start, int end) {
        this.start = start;
        this.end = end;
    }

    public static final int threadhold = 5;

    @Override
    protected Long compute() {
        Long sum = 0L;

        // 如果任务足够小, 就直接执行
        boolean canCompute = (end - start) &lt;= threadhold;
        if (canCompute) {
            for (int i = start; i &lt;= end; i++) {
                sum = sum + i;
            }
        } else {
            // 任务大于阈值, 分裂为2个任务
            int middle = (start + end) / 2;
            SumTask subTask1 = new SumTask(start, middle);
            SumTask subTask2 = new SumTask(middle + 1, end);

            invokeAll(subTask1, subTask2);

            Long sum1 = subTask1.join();
            Long sum2 = subTask2.join();

            // 结果合并
            sum = sum1 + sum2;
        }
        return sum;
    }
}
</code></pre><p>主程序</p>
<pre tabindex="0"><code>//分任务求和
public class SumTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建执行线程池
        ForkJoinPool pool = new ForkJoinPool();
        //ForkJoinPool pool = new ForkJoinPool(4);

        //创建任务
        SumTask task = new SumTask(1, 10000000);

        //提交任务
        ForkJoinTask&lt;Long&gt; result = pool.submit(task);

        //等待结果
        do {
            System.out.printf(&#34;Main: Thread Count: %d\n&#34;,pool.getActiveThreadCount());
            System.out.printf(&#34;Main: Paralelism: %d\n&#34;,pool.getParallelism());
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } while (!task.isDone());

        //输出结果
        System.out.println(result.get().toString());
    }
}
</code></pre><h2 id="59-定时任务执行"><strong>5.9 定时任务执行</strong></h2>
<p>固定某个时间点执行，或者周期性执行、</p>
<h3 id="简单定时机制"><strong>简单定时机制</strong></h3>
<h3 id="executor定时器"><strong>executor+定时器</strong></h3>
<p>executeAtFixTime() 在指定时间点启动</p>
<p>executeFixedRate() 每三秒钟执行一次</p>
<p>executeFixedDelay() 跟上个函数差不多，不同的是从上个任务结束时间开始算三秒</p>
<pre tabindex="0"><code>package schedule;

import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorTest {

    public static void main(String[] a) throws Exception
    {
        //executeAtFixTime();
        //executeFixedRate();  //3s
        executeFixedDelay();  //4s
    }

    public static void executeAtFixTime() throws Exception {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.schedule(
                new MyTask(),
                1,
                TimeUnit.SECONDS);

        Thread.sleep(20000);
        executor.shutdown();
    }

    /**
     * 周期任务 固定速率 是以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕，
     * 如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。
     * @throws Exception
     */
    public static void executeFixedRate() throws Exception {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.scheduleAtFixedRate(
                new MyTask(),
                1,
                3000,
                TimeUnit.MILLISECONDS);

        Thread.sleep(20000);
        executor.shutdown();
    }

    /**
     * 周期任务 固定延时 是以上一个任务结束时开始计时，period时间过去后，立即执行。
     * @throws Exception
     */
    public static void executeFixedDelay() throws Exception {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.scheduleWithFixedDelay(
                new MyTask(),
                1,
                3000,
                TimeUnit.MILLISECONDS);

        Thread.sleep(20000);
        executor.shutdown();
    }
}

class MyTask implements Runnable {
    public void run() {
        System.out.println(&#34;时间为：&#34; + new Date());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //System.out.println(&#34;时间为：&#34; + new Date());
    }
}
</code></pre><h3 id="quartz"><strong>Quartz</strong></h3>
<p>有trigger这个概念，可以控制执行次数</p>
<h1 id="第六章-网络编程"><strong>第六章 网络编程</strong></h1>
<h2 id="61-网络基础"><strong>6.1 网络基础</strong></h2>
<p>每个计算设备上都有若干个网卡，每个网卡上有(全球唯一)单独的硬件地址，MAC地址</p>
<p>IP地址：每个网卡/机器都有一个或多个IP地址</p>
<p>Windows平台ipconfig, Linux/Mac平台ifconfig：查询ip地址</p>
<p>在Windows/Linux/Mac上都可以通过netstat -an：查询端口</p>
<p>公网(万维网/互联网)和内网(局域网)：网络是分层的，最外层是公网/互联网，底下的每层都是内网</p>
<p>ip地址可以在每个层次的网重用，tracert 看当前机器 和目标机器的访问中继</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116154254.png" alt=""></p>
<h2 id="62-java-udp协议"><strong>6.2 java UDP协议</strong></h2>
<p>计算机通讯：数据从一个IP的port出发（发送方），运输到另外一个IP的port（接收方）</p>
<p>无连接无状态的通讯协议：发送方发送消息，如果接收方刚好在目的地，则可以接受。如果不在，那这个消息就丢失了，发送方也无法得知是否发送成功</p>
<p>UDP的好处就是简单，节省，经济</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116155009.png" alt=""></p>
<h3 id="udpsender"><strong>UDPsender</strong></h3>
<p>发送信息给指定端口</p>
<p>先定义管道DatagramSocket，再定义集装箱DatagramPacket</p>
<pre tabindex="0"><code>import java.net.*;
public class UdpSend
{
    public static void main(String [] args) throws Exception
    {
        DatagramSocket ds=new DatagramSocket();
        String str=&#34;hello world&#34;;
        DatagramPacket dp=new DatagramPacket(str.getBytes(),str.length(),
                InetAddress.getByName(&#34;127.0.0.1&#34;),3000);

        System.out.println(&#34;UdpSend: 我要发送信息&#34;);
        ds.send(dp);
        System.out.println(&#34;UdpSend: 我发送信息结束&#34;);

        Thread.sleep(1000);
        byte [] buf=new byte[1024];
        DatagramPacket dp2=new DatagramPacket(buf,1024);
        System.out.println(&#34;UdpSend: 我在等待信息&#34;);
        ds.receive(dp2);
        System.out.println(&#34;UdpSend: 我接收到信息&#34;);
        String str2=new String(dp2.getData(),0,dp2.getLength()) +
                &#34; from &#34; + dp2.getAddress().getHostAddress()+&#34;:&#34;+dp2.getPort();
        System.out.println(str2);

        ds.close();
    }
}
</code></pre><h3 id="udprecv"><strong>UDPrecv</strong></h3>
<p>同样是先定义管道DatagramSocket，再定义集装箱DatagramPacket</p>
<p>从12行开始等待信息，接受到之后再发送一条信息出去</p>
<pre tabindex="0"><code>import java.net.*;
public class UdpRecv
{
    public static void main(String[] args) throws Exception
    {
        DatagramSocket  ds=new DatagramSocket(3000);
        byte [] buf=new byte[1024];
        DatagramPacket dp=new DatagramPacket(buf,1024);

        System.out.println(&#34;UdpRecv: 我在等待信息&#34;);
        ds.receive(dp);
        System.out.println(&#34;UdpRecv: 我接收到信息&#34;);
        String strRecv=new String(dp.getData(),0,dp.getLength()) +
        &#34; from &#34; + dp.getAddress().getHostAddress()+&#34;:&#34;+dp.getPort();
        System.out.println(strRecv);

        Thread.sleep(1000);
        System.out.println(&#34;UdpRecv: 我要发送信息&#34;);
        String str=&#34;hello world 222&#34;;
        DatagramPacket dp2=new DatagramPacket(str.getBytes(),str.length(),
                InetAddress.getByName(&#34;127.0.0.1&#34;),dp.getPort());
        ds.send(dp2);
        System.out.println(&#34;UdpRecv: 我发送信息结束&#34;);
        ds.close();
    }
}
</code></pre><p>在eclipse运行结果</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116160548.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116160524.png" alt=""></p>
<p>在命令行运行结果</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116161110.png" alt=""></p>
<h2 id="63-java-tcp协议"><strong>6.3 java TCP协议</strong></h2>
<p>①服务器：创建一个ServerSocket，等待连接</p>
<p>②客户机：创建一个Socket，连接到服务器</p>
<p>③服务器：ServerSocket接收到连接，创建一个Socket和客户的 Socket建立专线连接，后续服务器和客户机的对话(这一对Socket) 会在一个单独的线程（服务器端）上运行</p>
<p>④服务器的ServerSocket继续等待连接，返回①</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116161602.png" alt=""></p>
<p>用到的两个类</p>
<ul>
<li>
<p><strong>ServerSocket</strong>: 服务器码头，需要绑定port</p>
<p>如果有多块网卡，需要绑定一个IP地址</p>
</li>
<li>
<p><strong>Socket</strong>: 运输通道</p>
<p>客户端需要绑定服务器的地址和Port</p>
<p>客户端往Socket输入流写入数据，送到服务端</p>
<p>客户端从Socket输出流取服务器端过来的数据，服务端反之亦然</p>
</li>
</ul>
<h3 id="tcpclient-客户端"><strong>TcpClient 客户端</strong></h3>
<p>作用是向服务端输出信息，并得到服务端传过来的回应</p>
<pre tabindex="0"><code>import java.net.*;
import java.io.*;

public class TcpClient {
    public static void main(String[] args) {
        try {
            Socket s = new Socket(InetAddress.getByName(&#34;127.0.0.1&#34;), 8001); //需要服务端先开启

            //同一个通道，服务端的输出流就是客户端的输入流；服务端的输入流就是客户端的输出流
            InputStream ips = s.getInputStream();    //开启通道的输入流
            BufferedReader brNet = new BufferedReader(new InputStreamReader(ips));

            OutputStream ops = s.getOutputStream();  //开启通道的输出流
            DataOutputStream dos = new DataOutputStream(ops);

            BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in));
            while (true)
            {
                String strWord = brKey.readLine();
                if (strWord.equalsIgnoreCase(&#34;quit&#34;))
                {
                    break;
                }
                else
                {
                    System.out.println(&#34;I want to send: &#34; + strWord);
                    dos.writeBytes(strWord + System.getProperty(&#34;line.separator&#34;));

                    System.out.println(&#34;Server said: &#34; + brNet.readLine());
                }
            }

            dos.close();
            brNet.close();
            brKey.close();
            s.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="tcpserver-服务端"><strong>TcpServer 服务端</strong></h3>
<p>可以接纳多个客户端，每一个客户端来了之后就会发送一个hello client</p>
<pre tabindex="0"><code>import java.net.*;
public class TcpServer2
{
    public static void main(String [] args)
    {
        try
        {
            ServerSocket ss=new ServerSocket(8001);
            while(true)
            {
                Socket s=ss.accept();
                System.out.println(&#34;来了一个client&#34;);
                new Thread(new Worker(s)).start();
            }
            //ss.close();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
    }
}
</code></pre><p>其中worker是一个实现了runnable接口的并发类</p>
<pre tabindex="0"><code>import java.net.*;
import java.io.*;

class Worker implements Runnable {
    Socket s;

    public Worker(Socket s) {
        this.s = s;
    }

    public void run() {
        try {
            System.out.println(&#34;服务人员已经启动&#34;);
            InputStream ips = s.getInputStream();
            OutputStream ops = s.getOutputStream();

            BufferedReader br = new BufferedReader(new InputStreamReader(ips));
            DataOutputStream dos = new DataOutputStream(ops);
            while (true) {
                String strWord = br.readLine();
                System.out.println(&#34;client said:&#34; + strWord +&#34;:&#34; + strWord.length());
                if (strWord.equalsIgnoreCase(&#34;quit&#34;))
                    break;
                String strEcho = strWord + &#34; 666&#34;;
                // dos.writeBytes(strWord +&#34;----&gt;&#34;+ strEcho +&#34;\r\n&#34;);
                System.out.println(&#34;server said:&#34; + strWord + &#34;----&gt;&#34; + strEcho);
                dos.writeBytes(strWord + &#34;----&gt;&#34; + strEcho + System.getProperty(&#34;line.separator&#34;));
            }
            br.close();
            // 关闭包装类，会自动关闭包装类中所包装的底层类。所以不用调用ips.close()
            dos.close();
            s.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>命令行运行结果</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116164602.png" alt=""></p>
<h2 id="64-http"><strong>6.4 HTTP</strong></h2>
<p>网页是特殊的网络服务(HTTP, Hypertext Transfer Protocol)</p>
<p>步骤一 在浏览器输入URL地址</p>
<p>步骤二 浏览器将连接到远程服务器上(IP+80Port)</p>
<p>步骤三 请求下载一个HTML文件下来，放到本地临时文件夹中</p>
<p>步骤四 在浏览器显示出来</p>
<p><strong>Java HTTP编程 (java.net包)</strong> 支持模拟成浏览器的方式去访问网页</p>
<ul>
<li>
<p>URL , Uniform Resource Locator，代表一个资源</p>
<p><a href="http://www.ecnu.edu.cn/index.html?a=1&amp;b=2&amp;c=3" target="_blank">http://www.ecnu.edu.cn/index.html?a=1&amp;b=2&amp;c=3</a></p>
</li>
<li>
<p>URLConnection 获取资源的连接器</p>
<p>根据URL的openConnection()方法获得URLConnection</p>
<p>connect方法，建立和资源的联系通</p>
<p>getInputStream方法，获取资源的内容</p>
</li>
</ul>
<h3 id="urlconnectionget"><strong>URLConnectionGet</strong></h3>
<p>以get的方式访问百度，希望拿下百度首页的内容</p>
<p>java能拿到的都是html源代码，不能渲染成漂亮的网页</p>
<pre tabindex="0"><code>
import java.io.*;
import java.net.*;
import java.util.*;

public class URLConnectionGetTest
{
   public static void main(String[] args)
   {
      try
      {
         String urlName = &#34;http://www.baidu.com&#34;;

         URL url = new URL(urlName);
         URLConnection connection = url.openConnection();
         connection.connect();

         // 打印http的头部信息

         Map&lt;String, List&lt;String&gt;&gt; headers = connection.getHeaderFields();
         for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : headers.entrySet())
         {
            String key = entry.getKey();
            for (String value : entry.getValue())
               System.out.println(key + &#34;: &#34; + value);
         }

         // 输出将要收到的内容属性信息

         System.out.println(&#34;----------&#34;);
         System.out.println(&#34;getContentType: &#34; + connection.getContentType());
         System.out.println(&#34;getContentLength: &#34; + connection.getContentLength());
         System.out.println(&#34;getContentEncoding: &#34; + connection.getContentEncoding());
         System.out.println(&#34;getDate: &#34; + connection.getDate());
         System.out.println(&#34;getExpiration: &#34; + connection.getExpiration());
         System.out.println(&#34;getLastModifed: &#34; + connection.getLastModified());
         System.out.println(&#34;----------&#34;);

         BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), &#34;UTF-8&#34;));

         // 输出收到的内容
         String line = &#34;&#34;;
         while((line=br.readLine()) != null)
         {
             System.out.println(line);
         }
         br.close();
      }
      catch (IOException e)
      {
         e.printStackTrace();
      }
   }
}
</code></pre><h3 id="urlconnectionpost"><strong>URLConnectionPost</strong></h3>
<p>去一个联邦快递查询右边的网站</p>
<p>在代码中将信息填写进网站的表单，然后post，就完成了对这个网页的提交访问</p>
<pre tabindex="0"><code>
import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.util.*;

public class URLConnectionPostTest
{
   public static void main(String[] args) throws IOException
   {
      String urlString = &#34;https://tools.usps.com/go/ZipLookupAction.action&#34;;
      Object userAgent = &#34;HTTPie/0.9.2&#34;;
      Object redirects = &#34;1&#34;;
      CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL));

      Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
      params.put(&#34;tAddress&#34;, &#34;1 Market Street&#34;);
      params.put(&#34;tCity&#34;, &#34;San Francisco&#34;);
      params.put(&#34;sState&#34;, &#34;CA&#34;);
      String result = doPost(new URL(urlString), params,
         userAgent == null ? null : userAgent.toString(),
         redirects == null ? -1 : Integer.parseInt(redirects.toString()));
      System.out.println(result);
   }

   public static String doPost(URL url, Map&lt;String, String&gt; nameValuePairs, String userAgent, int redirects)
         throws IOException
   {
      HttpURLConnection connection = (HttpURLConnection) url.openConnection();
      if (userAgent != null)
         connection.setRequestProperty(&#34;User-Agent&#34;, userAgent);

      if (redirects &gt;= 0)
         connection.setInstanceFollowRedirects(false);

      connection.setDoOutput(true);

      //输出请求的参数
      try (PrintWriter out = new PrintWriter(connection.getOutputStream()))
      {
         boolean first = true;
         for (Map.Entry&lt;String, String&gt; pair : nameValuePairs.entrySet())
         {
            //参数必须这样拼接 a=1&amp;b=2&amp;c=3
            if (first)
            {
                first = false;
            }
            else
            {
                out.print(&#39;&amp;&#39;);
            }
            String name = pair.getKey();
            String value = pair.getValue();
            out.print(name);
            out.print(&#39;=&#39;);
            out.print(URLEncoder.encode(value, &#34;UTF-8&#34;));
         }
      }
      String encoding = connection.getContentEncoding();
      if (encoding == null)
      {
          encoding = &#34;UTF-8&#34;;
      }

      if (redirects &gt; 0)
      {
         int responseCode = connection.getResponseCode();
         System.out.println(&#34;responseCode: &#34; + responseCode);
         if (responseCode == HttpURLConnection.HTTP_MOVED_PERM
               || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
               || responseCode == HttpURLConnection.HTTP_SEE_OTHER)
         {
            String location = connection.getHeaderField(&#34;Location&#34;);
            if (location != null)
            {
               URL base = connection.getURL();
               connection.disconnect();
               return doPost(new URL(base, location), nameValuePairs, userAgent, redirects - 1);
            }

         }
      }
      else if (redirects == 0)
      {
         throw new IOException(&#34;Too many redirects&#34;);
      }

      //接下来获取html 内容
      StringBuilder response = new StringBuilder();
      try (Scanner in = new Scanner(connection.getInputStream(), encoding))
      {
         while (in.hasNextLine())
         {
            response.append(in.nextLine());
            response.append(&#34;\n&#34;);
         }
      }
      catch (IOException e)
      {
         InputStream err = connection.getErrorStream();
         if (err == null) throw e;
         try (Scanner in = new Scanner(err))
         {
            response.append(in.nextLine());
            response.append(&#34;\n&#34;);
         }
      }

      return response.toString();
   }
}
</code></pre><h2 id="65-httpclient"><strong>6.5 HttpClient</strong></h2>
<p>两个包</p>
<p>java.net.http包，jdk自带的</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116171656.png" alt=""></p>
<h3 id="jdkhttpclientget"><strong>JDKHttpClientGet</strong></h3>
<pre tabindex="0"><code>public class JDKHttpClientGetTest {

    public static void main(String[] args) throws IOException, InterruptedException {
        doGet();
    }

    public static void doGet() {
        try{
            HttpClient client = HttpClient.newHttpClient();
            HttpRequest request = HttpRequest.newBuilder(URI.create(&#34;http://www.baidu.com&#34;)).build();
            HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println(response.body());
        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="jdkhttpclientpost"><strong>JDKHttpClientPost</strong></h3>
<pre tabindex="0"><code>public class JDKHttpClientPostTest {

    public static void main(String[] args) throws IOException, InterruptedException {
        doPost();
    }

    public static void doPost() {
        try {
            HttpClient client = HttpClient.newBuilder().build();
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(&#34;https://tools.usps.com/go/ZipLookupAction.action&#34;))
                    //.header(&#34;Content-Type&#34;,&#34;application/x-www-form-urlencoded&#34;)
                    .header(&#34;User-Agent&#34;, &#34;HTTPie/0.9.2&#34;)
                    .header(&#34;Content-Type&#34;,&#34;application/x-www-form-urlencoded;charset=utf-8&#34;)
                    //.method(&#34;POST&#34;, HttpRequest.BodyPublishers.ofString(&#34;tAddress=1 Market Street&amp;tCity=San Francisco&amp;sState=CA&#34;))
                    //.version(Version.HTTP_1_1)
                    .POST(HttpRequest.BodyPublishers.ofString(&#34;tAddress=&#34;
                        + URLEncoder.encode(&#34;1 Market Street&#34;, &#34;UTF-8&#34;)
                        + &#34;&amp;tCity=&#34; + URLEncoder.encode(&#34;San Francisco&#34;, &#34;UTF-8&#34;) + &#34;&amp;sState=CA&#34;))
                    //.POST(HttpRequest.BodyPublishers.ofString(&#34;tAddress=&#34; + URLEncoder.encode(&#34;1 Market Street&#34;, &#34;UTF-8&#34;) + &#34;&amp;tCity=&#34; + URLEncoder.encode(&#34;San Francisco&#34;, &#34;UTF-8&#34;) + &#34;&amp;sState=CA&#34;))
                    .build();
            HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println(response.statusCode());
            System.out.println(response.headers());
            System.out.println(response.body().toString());

        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h2 id="69-邮件"><strong>6.9 邮件</strong></h2>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116173755.png" alt=""></p>
<p>邮件客户端：Foxmail、OutLook(Express, Microsoft Outlook)、Thunderbird (linux平台)</p>
<p>邮件服务端：Microsoft Exchange Server、IBM Lotus Notes、SendMail, Qmail, James</p>
<p>主要协议(发送端口25, 接收端口110)</p>
<p>发送, SMTP, Simple Mail Transfer Protocol</p>
<p>接收, Pop3, Post Office Protocol 3, (POP)</p>
<p>接收, IMAP, Internet Message Access Protocol, IMAP4</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116194849.png" alt=""></p>
<p>在正式开发之前，需要去邮箱里面确认</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116194945.png" alt=""></p>
<p>添加依赖</p>
<pre tabindex="0"><code>&lt;dependencies&gt;
    &lt;!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;
        &lt;artifactId&gt;javax.mail&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="mailclientrecv"><strong>MailClientRecv</strong></h3>
<pre tabindex="0"><code>package tools;

import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;
import java.util.*;

public class MailClientRecv {
  private Session session;
  private Store store;
  private String username = &#34;13896796126@163.com&#34;;
  private String password = &#34; &#34;;
  private String popServer = &#34;pop.163.com&#34;;

  public void init()throws Exception
  {
    //设置属性
    Properties  props = new Properties();
    props.put(&#34;mail.store.protocol&#34;, &#34;pop3&#34;);
    props.put(&#34;mail.imap.class&#34;, &#34;com.sun.mail.imap.IMAPStore&#34;);
    props.put(&#34;mail.pop3.class&#34;, &#34;com.sun.mail.pop3.POP3Store&#34;);

    // 创建Session对象
    session = Session.getInstance(props,null);
    session.setDebug(false); //输出跟踪日志

    // 创建Store对象
    store = session.getStore(&#34;pop3&#34;);

    //连接到收邮件服务器
    store.connect(popServer,username,password);
  }

  public void receiveMessage()throws Exception
  {
    String folderName = &#34;inbox&#34;;
    Folder folder=store.getFolder(folderName);
    if(folder==null)
    {
        throw new Exception(folderName+&#34;邮件夹不存在&#34;);
    }
    //打开信箱
    folder.open(Folder.READ_ONLY);
    System.out.println(&#34;您的收件箱有&#34;+folder.getMessageCount()+&#34;封邮件.&#34;);
    System.out.println(&#34;您的收件箱有&#34;+folder.getUnreadMessageCount()+&#34;封未读的邮件.&#34;);

    //读邮件
    Message[] messages=folder.getMessages();
    //for(int i=1;i&lt;=messages.length;i++)
    for(int i=1;i&lt;=3;i++)
    {
      System.out.println(&#34;------第&#34;+i+&#34;封邮件-------&#34;);
      //打印邮件信息
      Message message = messages[i];
      //folder.getMessage(i).writeTo(System.out);
      System.out.println((message.getFrom())[0]);
      System.out.println(message.getSubject());
      System.out.println();
    }
    folder.close(false);  //关闭邮件夹
  }

  public void close()throws Exception
  {
    store.close();
  }

  public static void main(String[] args)throws Exception {
    MailClientRecv client=new MailClientRecv();
    //初始化
    client.init();
    //接收邮件
    client.receiveMessage();
    //关闭连接
    client.close();
  }
}
</code></pre><p>运行结果</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116200310.png" alt=""></p>
<h3 id="mailclientsend"><strong>MailClientSend</strong></h3>
<pre tabindex="0"><code>package tools;

import javax.mail.*;
import java.util.*;
import messages.*;

public class MailClientSend {
  private Session session;
  private Transport transport;
  private String username = &#34;zhangcaiyii@163.com&#34;;
  private String password = &#34;ZCY929weilaikeqi&#34;;
  private String smtpServer = &#34;smtp.163.com&#34;;

  public void init()throws Exception
  {
    //设置属性
    Properties  props = new Properties();
    props.put(&#34;mail.transport.protocol&#34;, &#34;smtp&#34;);
    props.put(&#34;mail.smtp.class&#34;, &#34;com.sun.mail.smtp.SMTPTransport&#34;);
    props.put(&#34;mail.smtp.host&#34;, smtpServer); //设置发送邮件服务器
    props.put(&#34;mail.smtp.port&#34;, &#34;25&#34;);
    props.put(&#34;mail.smtp.auth&#34;, &#34;true&#34;); //SMTP服务器需要身份验证

    // 创建Session对象
    session = Session.getInstance(props,new Authenticator(){   //验账账户
        public PasswordAuthentication getPasswordAuthentication() {
          return new PasswordAuthentication(username, password);
        }
 });
    session.setDebug(true); //输出跟踪日志

    // 创建Transport对象
    transport = session.getTransport();
  }

  public void sendMessage()throws Exception{
    //创建一个邮件
    //Message msg = TextMessage.generate();  //另写一个类，见下面
    //Message msg = HtmlMessage.generate();
    Message msg = AttachmentMessage.generate();
    //发送邮件
    transport.connect();
    transport.sendMessage(msg, msg.getAllRecipients());
    //打印结果
    System.out.println(&#34;邮件已经成功发送&#34;);
  }

  public void close()throws Exception
  {
    transport.close();
  }

  public static void main(String[] args)throws Exception {

    MailClientSend client=new MailClientSend();
    //初始化
    client.init();
    //发送邮件
    client.sendMessage();
    //关闭连接
    client.close();
  }
}
</code></pre><p>发送文本右键 TextMessage</p>
<pre tabindex="0"><code>public class TextMessage {
    public static MimeMessage generate() throws Exception {
        String from = &#34;lychen@sei.ecnu.edu.cn &#34;; // 发件人地址
        String to = &#34;chenliangyu1980@126.com&#34;; // 收件人地址

        String subject = &#34;test&#34;;
        String body = &#34;您好,这是来自一封chenliangyu的测试邮件&#34;;

        // 创建Session实例对象
        Session session = Session.getDefaultInstance(new Properties());
        // 创建MimeMessage实例对象
        MimeMessage message = new MimeMessage(session);
        // 设置发件人
        message.setFrom(new InternetAddress(from));
        // 设置收件人
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));
        // 设置发送日期
        message.setSentDate(new Date());
        // 设置邮件主题
        message.setSubject(subject);
        // 设置纯文本内容的邮件正文
        message.setText(body);
        // 保存并生成最终的邮件内容
        message.saveChanges();

        // 把MimeMessage对象中的内容写入到文件中
        //msg.writeTo(new FileOutputStream(&#34;e:/test.eml&#34;));
        return message;
    }
}
</code></pre><p>发送html邮件 HTMLMessage</p>
<pre tabindex="0"><code>public class HtmlMessage {
    public static MimeMessage generate() throws Exception
    {
        String from = &#34;lychen@sei.ecnu.edu.cn &#34;; // 发件人地址
        String to = &#34;chenliangyu1980@126.com&#34;; // 收件人地址

        String subject = &#34;HTML邮件&#34;;
        String body = &#34;&lt;a href=http://www.ecnu.edu.cn&gt;&#34;
          + &#34;&lt;h4&gt;欢迎大家访问我们的网站&lt;/h4&gt;&lt;/a&gt;&lt;/br&gt;&#34;
          + &#34;&lt;img src=\&#34;https://news.ecnu.edu.cn/_upload/article/images/2e/e2/6b554d034c9192101208c732195e/16a6ec66-6729-4469-a5f4-0435e0f2e66a.jpg\&#34;&gt;&#34;;

        // 创建Session实例对象
        Session session = Session.getDefaultInstance(new Properties());
        // 创建MimeMessage实例对象
        MimeMessage message = new MimeMessage(session);
        // 设置发件人
        message.setFrom(new InternetAddress(from));
        // 设置收件人
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));
        // 设置发送日期
        message.setSentDate(new Date());
        // 设置邮件主题
        message.setSubject(subject);
        // 设置HTML格式的邮件正文
        message.setContent(body, &#34;text/html;charset=gb2312&#34;);
        // 保存并生成最终的邮件内容
        message.saveChanges();

        // 把MimeMessage对象中的内容写入到文件中
        //msg.writeTo(new FileOutputStream(&#34;e:/HtmlMessage.eml&#34;));
        return message;
    }
}
</code></pre><h1 id="第七章-数据库编程"><strong>第七章 数据库编程</strong></h1>
<h2 id="72-jdbc基本操作"><strong>7.2 JDBC基本操作</strong></h2>
<p>java和数据库是两套平行的系统，要想连接需要借助jdbc(主流)</p>
<p>jdbc sql连接操作</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116203038.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116203132.png" alt=""></p>
<h3 id="select"><strong>Select</strong></h3>
<p>首先添加mysql依赖</p>
<pre tabindex="0"><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.25&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>注意一个大坑，配置文件里mysql-connector-jar和本地mysql的版本一定要一致！否则会报错</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116210905.png" alt=""></p>
<p>该代码可以直接用</p>
<p>要改的地方只有数据库名，用户名密码，select语句，还有输出是get的数据类型</p>
<pre tabindex="0"><code>
import java.sql.*;

public class SelectTest {
    public static void main(String[] args){

        //构建Java和数据库之间的桥梁介质
        try{
            Class.forName(&#34;com.mysql.jdbc.Driver&#34;);
            System.out.println(&#34;注册驱动成功!&#34;);
        }catch(ClassNotFoundException e1){
            System.out.println(&#34;注册驱动失败!&#34;);
            e1.printStackTrace();
            return;
        }

        String url=&#34;jdbc:mysql://localhost:3306/blog?useSSL=false&#34;;
        Connection conn = null;
        try {
            //构建Java和数据库之间的桥梁：URL，用户名，密码
            conn = DriverManager.getConnection(url, &#34;root&#34;, &#34; &#34;);

            //构建数据库执行者
            Statement stmt = conn.createStatement();
            System.out.println(&#34;创建Statement成功！&#34;);

            //执行SQL语句并返回结果到ResultSet
            ResultSet rs = stmt.executeQuery(&#34;select id, name, age from t_person order by id&#34;);

            //开始遍历ResultSet数据
            while(rs.next())
            {
                System.out.println(rs.getInt(1) + &#34;,&#34; + rs.getString(2) + &#34;,&#34; + rs.getInt(&#34;age&#34;));
            }

            rs.close();
            stmt.close();

        } catch (SQLException e){
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if(null != conn)
                {
                    conn.close();
                }
            }
            catch (SQLException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>打开navicat，连接到服务器，并创建表 t_person</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116211201.png" alt=""></p>
<p>运行结果</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116211322.png" alt=""></p>
<h3 id="update"><strong>Update</strong></h3>
<p>该代码跟select唯一不同的就是，执行语句一个是stmt.executeQuery(sql)，一个是stmt.executeUpdate(sql)</p>
<p>也可以直接用，用的时候改改几个sql语句，数据库名字，用户名密码就好</p>
<pre tabindex="0"><code>
import java.sql.*;

public class UpdateTest {
    public static void main(String[] args){
        executeUpdate(&#34;update t_person set age = 40 where id = 316&#34;);
        executeUpdate(&#34;insert into t_person(id, name, age) values(320, &#39;xuexiaonan&#39;, 22)&#34;);
        executeUpdate(&#34;delete from t_person where id = 318&#34;);
    }
    public static void executeUpdate(String sql)
    {
        //构建Java和数据库之间的桥梁介质
        try{
            Class.forName(&#34;com.mysql.cj.jdbc.Driver&#34;);
            System.out.println(&#34;注册驱动成功!&#34;);
        }catch(ClassNotFoundException e1){
            System.out.println(&#34;注册驱动失败!&#34;);
            e1.printStackTrace();
        }

        String url=&#34;jdbc:mysql://localhost:3306/blog?useSSL=false&#34;;
        Connection conn = null;
        try {
            //构建Java和数据库之间的桥梁：URL，用户名，密码
            conn = DriverManager.getConnection(url, &#34;root&#34;, &#34;zcy123456&#34;);

            //构建数据库执行者
            Statement stmt = conn.createStatement();
            System.out.println(&#34;创建Statement成功！&#34;);

            //执行SQL语句
            int result = stmt.executeUpdate(sql);

            stmt.close();

        } catch (SQLException e){
            e.printStackTrace();
        }
        finally
        {
            try
            {
                if(null != conn)
                {
                    conn.close();
                }
            }
            catch (SQLException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>运行结果</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116211923.png" alt=""></p>
<h2 id="73-jdbc高级特性"><strong>7.3 JDBC高级特性</strong></h2>
<h3 id="addbsh"><strong>addbsh</strong></h3>
<p>preparedStatement 使用问号来代替字符串拼接</p>
<h2 id="74-数据库连接池"><strong>7.4 数据库连接池</strong></h2>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116213937.png" alt=""></p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116214019.png" alt=""></p>
<p>数据库连接池</p>
<p><img src="https://caiyiimg.oss-cn-shanghai.aliyuncs.com/typora/20211116214149.png" alt=""></p>
<p>主程序</p>
<pre tabindex="0"><code>
import java.sql.*;

public class SelectTest {
    public static void main(String[] args){

        Connection conn = null;
        try {
            //从c3p0获取
            //conn = C3p0Factory1.getConnection();
            //conn = C3p0Factory2.getConnection();

            //从Druid获取
            //conn = DruidFactory1.getConnection();
            conn = DruidFactory2.getConnection();

            //构建数据库执行者
            Statement stmt = conn.createStatement();
            System.out.println(&#34;创建Statement成功！&#34;);

            //执行SQL语句并返回结果到ResultSet
            ResultSet rs = stmt.executeQuery(&#34;select id, name, age from t_person order by id&#34;);

            //开始遍历ResultSet数据
            while(rs.next())
            {
                System.out.println(rs.getInt(1) + &#34;,&#34; + rs.getString(2) + &#34;,&#34; + rs.getInt(&#34;age&#34;));
            }

            rs.close();
            stmt.close();

        } catch (Exception e){
            e.printStackTrace();
        } finally {
            try {
                if(null != conn) {
                    conn.close();
                }
            } catch (SQLException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre><h3 id="c3p0"><strong>c3p0</strong></h3>
<p>引入依赖</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.mchange&lt;/groupId&gt;
    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
    &lt;version&gt;0.9.5.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>c3p0是管理数据库连接的，它不能代替数据库连接</p>

      </div>
      








  
  
  
        

        
          
        

      
    
        

        
          
        

      
    
        

      
    
        

        
          
        

        
        
      


<footer id="article-footer">
  <time id="article-last-updated" datetime="2025-07-06"><i class="icon icon-calendar"></i>&nbsp;Last updated: 2025-07-06</time>

  
    <a id="article-prev-link" href="/docs/java-basic/"><i class="icon icon-prev icon-colored"></i> Prev</a>
  

  
    <a id="article-next-link"  href="/docs/java-data-structure/">Next <i class="icon icon-next icon-colored"></i></a>
  
</footer>
    </article>
    <aside id="toc">
  <span class="btn-close"><i class="icon icon-close"></i></span>
  <div class="sticky">
    <strong><i class="icon icon-toc"></i> On this page</strong>
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#maven概念"><strong>Maven概念</strong></a></li>
        <li><a href="#maven编译工作流程"><strong>Maven编译工作流程</strong></a></li>
        <li><a href="#maven目录结构"><strong>Maven目录结构</strong></a></li>
        <li><a href="#maven项目构建流程"><strong>Maven项目构建流程</strong></a></li>
        <li><a href="#maven报错解决办法"><strong>Maven报错解决办法</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#31-java字符编码"><strong>3.1 Java字符编码</strong></a></li>
    <li><a href="#32-java国际化编程"><strong>3.2 Java国际化编程</strong></a>
      <ul>
        <li><a href="#properties语言文件"><strong>properties语言文件</strong></a></li>
        <li><a href="#国际化转化演示"><strong>国际化转化演示</strong></a></li>
        <li><a href="#解决引入javautil-爆红的方法"><strong>解决引入java.util 爆红的方法</strong></a></li>
      </ul>
    </li>
    <li><a href="#33-高级字符串处理"><strong>3.3 高级字符串处理</strong></a>
      <ul>
        <li><a href="#331-正则表达式"><strong>3.3.1 正则表达式</strong></a></li>
        <li><a href="#332-其他字符串处理"><strong>3.3.2 其他字符串处理</strong></a></li>
        <li><a href="#集合和字符串互转"><strong>集合和字符串互转</strong></a></li>
        <li><a href="#字符串转义"><strong>字符串转义</strong></a></li>
        <li><a href="#变量名字格式化驼峰命名"><strong>变量名字格式化(驼峰命名)</strong></a></li>
        <li><a href="#从字符串到输入流"><strong>从字符串到输入流</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#41-xml-dom解析"><strong>4.1 XML DOM解析</strong></a></li>
    <li><a href="#42-sax-dom解析"><strong>4.2 SAX DOM解析</strong></a></li>
    <li><a href="#43-stax-dom解析"><strong>4.3 Stax DOM解析</strong></a></li>
    <li><a href="#44-json解析"><strong>4.4 JSON解析</strong></a>
      <ul>
        <li><a href="#orgjson"><strong>OrgJson</strong></a></li>
        <li><a href="#gson"><strong>GSON</strong></a></li>
        <li><a href="#jackson"><strong>Jackson</strong></a></li>
      </ul>
    </li>
    <li><a href="#45-图形图像解析"><strong>4.5 图形图像解析</strong></a>
      <ul>
        <li><a href="#读和写图片"><strong>读和写图片</strong></a></li>
        <li><a href="#切割矩形"><strong>切割矩形</strong></a></li>
        <li><a href="#横向拼接"><strong>横向拼接</strong></a></li>
        <li><a href="#纵向拼接"><strong>纵向拼接</strong></a></li>
        <li><a href="#应用-验证码的生成"><strong>应用 验证码的生成</strong></a></li>
        <li><a href="#应用-统计图生成"><strong>应用 统计图生成</strong></a></li>
      </ul>
    </li>
    <li><a href="#46-条形码和二维码解析"><strong>4.6 条形码和二维码解析</strong></a></li>
    <li><a href="#47-docx文件解析"><strong>4.7 DOCX文件解析</strong></a></li>
    <li><a href="#48-表格文件的处理"><strong>4.8 表格文件的处理</strong></a>
      <ul>
        <li><a href="#写xlsx文件"><strong>写xlsx文件</strong></a></li>
        <li><a href="#读xlsx文件"><strong>读xlsx文件</strong></a></li>
        <li><a href="#读csv文件"><strong>读csv文件</strong></a></li>
        <li><a href="#写csv文件"><strong>写csv文件</strong></a></li>
      </ul>
    </li>
    <li><a href="#49-pdf文件的处理"><strong>4.9 PDF文件的处理</strong></a>
      <ul>
        <li><a href="#抽取pdf的文本"><strong>抽取pdf的文本</strong></a></li>
        <li><a href="#写pdf"><strong>写pdf</strong></a></li>
        <li><a href="#合并两个pdf"><strong>合并两个pdf</strong></a></li>
        <li><a href="#删除一页pdf"><strong>删除一页pdf</strong></a></li>
        <li><a href="#xdocreport类"><strong>XdocReport类</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#51-多线程的生命周期"><strong>5.1 多线程的生命周期</strong></a>
      <ul>
        <li><a href="#java多线程的创建"><strong>java多线程的创建</strong></a></li>
        <li><a href="#java多线程的启动"><strong>java多线程的启动</strong></a></li>
        <li><a href="#java多线程的结束"><strong>java多线程的结束</strong></a></li>
      </ul>
    </li>
    <li><a href="#52-多线程信息共享"><strong>5.2 多线程信息共享</strong></a></li>
    <li><a href="#53-多线程管理"><strong>5.3 多线程管理</strong></a></li>
    <li><a href="#55-java并发框架-executor"><strong>5.5 java并发框架 executor</strong></a></li>
    <li><a href="#56-fork-join"><strong>5.6 Fork-join</strong></a></li>
    <li><a href="#59-定时任务执行"><strong>5.9 定时任务执行</strong></a>
      <ul>
        <li><a href="#简单定时机制"><strong>简单定时机制</strong></a></li>
        <li><a href="#executor定时器"><strong>executor+定时器</strong></a></li>
        <li><a href="#quartz"><strong>Quartz</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#61-网络基础"><strong>6.1 网络基础</strong></a></li>
    <li><a href="#62-java-udp协议"><strong>6.2 java UDP协议</strong></a>
      <ul>
        <li><a href="#udpsender"><strong>UDPsender</strong></a></li>
        <li><a href="#udprecv"><strong>UDPrecv</strong></a></li>
      </ul>
    </li>
    <li><a href="#63-java-tcp协议"><strong>6.3 java TCP协议</strong></a>
      <ul>
        <li><a href="#tcpclient-客户端"><strong>TcpClient 客户端</strong></a></li>
        <li><a href="#tcpserver-服务端"><strong>TcpServer 服务端</strong></a></li>
      </ul>
    </li>
    <li><a href="#64-http"><strong>6.4 HTTP</strong></a>
      <ul>
        <li><a href="#urlconnectionget"><strong>URLConnectionGet</strong></a></li>
        <li><a href="#urlconnectionpost"><strong>URLConnectionPost</strong></a></li>
      </ul>
    </li>
    <li><a href="#65-httpclient"><strong>6.5 HttpClient</strong></a>
      <ul>
        <li><a href="#jdkhttpclientget"><strong>JDKHttpClientGet</strong></a></li>
        <li><a href="#jdkhttpclientpost"><strong>JDKHttpClientPost</strong></a></li>
      </ul>
    </li>
    <li><a href="#69-邮件"><strong>6.9 邮件</strong></a>
      <ul>
        <li><a href="#mailclientrecv"><strong>MailClientRecv</strong></a></li>
        <li><a href="#mailclientsend"><strong>MailClientSend</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#72-jdbc基本操作"><strong>7.2 JDBC基本操作</strong></a>
      <ul>
        <li><a href="#select"><strong>Select</strong></a></li>
        <li><a href="#update"><strong>Update</strong></a></li>
      </ul>
    </li>
    <li><a href="#73-jdbc高级特性"><strong>7.3 JDBC高级特性</strong></a>
      <ul>
        <li><a href="#addbsh"><strong>addbsh</strong></a></li>
      </ul>
    </li>
    <li><a href="#74-数据库连接池"><strong>7.4 数据库连接池</strong></a>
      <ul>
        <li><a href="#c3p0"><strong>c3p0</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</aside>
  </main>
</div>

    <footer id="site-footer">
  
  <div id="site-footer-copyright">
    <a href="https://zcy530.github.io/" target="_blank">
      <i class="icon icon-copyright"></i> 2025 Caiyi Zhang
    </a>
  </div>

  
  <div id="site-footer-social">

    

    

    

    

  </div>

  
  <div id="site-footer-fund">

    

    

  </div>

  
  <div id="site-footer-love">
    Made with Hugo and Duracu <i class="icon icon-love icon-colored"></i> &nbsp;</a>
  </div>
</footer>
    






<script type="text/javascript" src="/js/base.min.js"></script>



  
  <script src="/js/component/docsearch.min.js"></script>
  <script type="application/javascript">
      docsearch({
          container: '#site-header-search',
          appId: '',
          indexName: '',
          apiKey: '',
      });
  </script>


<script type="application/javascript">
    if('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js?2025-07-27')
            .catch(function(err) {console.error('ServiceWorker registration failed: ', err);});
    }
</script>
  </body>
</html>